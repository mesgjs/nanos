{"version":3,"file":"nanos.min.esm.js","sources":["../src/nanos.esm.js"],"sourcesContent":["/*\n * NANOS - Named and numbered ordered storage\n * Copyright 2024-2025 by Kappa Computer Solutions, LLC and Brian Katzung\n * Author: Brian Katzung <briank@kappacs.com>\n */\n\nimport { escapeJSString, unescapeJSString } from 'escape-js/escape.esm.js';\n\nexport const isIndex = key => /^(?:0|[1-9]\\d*)$/.test(key);\nexport const isNegIndex = key => /^-[1-9]\\d*$/.test(key);\n\nexport class NANOS {\n    constructor (...items) {\n\tthis.clear();\n\tthis.push(...items);\n    }\n\n    // Get value at key or index (negative index relative to end)\n    at (key, defVal) {\n\tthis._rio?.depend();\n\tkey = this.#wrapKey(key);\n\treturn Object.hasOwn(this._storage, key) ? this._storage[key] : defVal;\n    }\n\n    get autoPromote () { return this._autoPromote; }\n\n    set autoPromote (v) { this._autoPromote = v; }\n\n    clear () {\n\tif (this._locked) throw new TypeError('NANOS: Cannot clear after locking');\n\tthis._next = 0;\n\tthis._keys = [];\n\tthis._storage = {};\n\tthis._lockInd = undefined;\n\tdelete this._redacted;\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    // NOTE: unlike the delete statement, this returns the deleted value!\n    delete (key) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot delete after locking');\n\tconst skey = '' + key;\n\tconst ret = this._storage[skey];\n\tif (Object.hasOwn(this._storage, skey)) {\n\t    delete this._storage[skey];\n\t    this._keys = this._keys.filter(k => k !== skey);\n\t    this._rio?.changed();\n\t}\n\treturn ret;\n    }\n\n    depend () { this._rio?.depend(); }\n\n    /*\n     * Returns [ [ key1, value1 ], ... [ keyN, valueN ] ]\n     * Compact mode uses numeric index keys instead of the standard strings\n     * (e.g. 0 instead of '0').\n     */\n    *entries (compact = false) {\n\tthis._rio?.depend();\n\tconst ik = compact ? (k => isIndex(k) ? parseInt(k, 10) : k) : (k => k);\n\tfor (const k of this._keys) yield [ ik(k), this._storage[k] ];\n    }\n\n    // Returns a shallow copy of elements for which f(value, key) is true\n    filter (f) {\n\tthis._rio?.depend();\n\treturn new NANOS.fromEntries([...this.entries()].filter(kv => f(kv[1], kv[0], this)));\n    }\n\n    // Returns first [key, value] where f(value, key) is true; cf find, findIndex\n    find (f) {\n\tthis._rio?.depend();\n\tconst s = this._storage;\n\tfor (const k of this._keys) if (f(s[k], k, this)) return [k, s[k]];\n    }\n\n    // Returns last [key, value] where f(value, key) is true; cf findLast, findLastIndex\n    findLast (f) {\n\tthis._rio?.depend();\n\tconst s = this._storage;\n\tfor (const k of this._keys.toReversed()) if (f(s[k], k, this)) return [k, s[k]];\n    }\n\n    forEach (f) {\n\tthis._rio?.depend();\n\tfor (const k of this._keys) f(this._storage[k], k, this);\n    }\n\n    // [ [ key1, value1 ], ... [ keyN, valueN ] ]\n    fromEntries (entries, insert = false) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot fromEntries after locking');\n\tif (insert && this._lockInd) throw new TypeError('NANOS: Cannot insert fromEntries after index lock');\n\tconst batch = this._rio?.batch || (cb => cb());\n\tbatch(() => {\n\t    if (insert) for (const e of [...entries].reverse()) this.set(e[0], e[1], true);\n\t    else for (const e of entries) this.set(e[0], e[1]);\n\t    this._rio?.changed();\n\t});\n\treturn this;\n    }\n\n    /*\n     * [ key1, value1, ... keyN, valueN ]\n     * { type: '@NANOS@', next, pairs }\n     */\n    fromPairs (...pairs) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot fromPairs after locking');\n\tconst batch = this._rio?.batch || (cb => cb());\n\tif (pairs[0]?.type === '@NANOS@') {\n\t    batch(() => {\n\t\tthis.fromPairs(pairs[0].pairs);\n\t\tthis.next = pairs[0].next;\n\t\tthis._rio?.changed();\n\t    });\n\t    return this;\n\t}\n\tif (Array.isArray(pairs[0])) pairs = pairs[0];\n\tconst end = pairs.length - 1;\n\tbatch(() => {\n\t    for (let i = 0; i < end; i += 2) {\n\t\tif (pairs[i] === undefined && !(i + 1 in pairs)) ++this._next;\n\t\telse this.set(pairs[i], pairs[i + 1]);\n\t    }\n\t    this._rio?.changed();\n\t});\n\treturn this;\n    }\n\n    // Instead of \"key in NANOS\"\n    has (key) {\n\tthis._rio?.depend();\n\treturn Object.hasOwn(this._storage, this.#wrapKey(key));\n    }\n\n    includes (value) {\n\treturn this.keyOf(value) !== undefined;\n    }\n\n    // Just the index entries\n    *indexEntries (compact = false) {\n\tfor (const e of this.entries(compact)) if (isIndex(e[0])) yield e;\n    }\n\n    // Just the index keys\n    *indexKeys () {\n\tthis._rio?.depend();\n\tfor (const k of this._keys) if (isIndex(k)) yield k;\n    }\n\n    // Is a key/value (or, if undef, the key-set) locked?\n    isLocked (key) {\n\tthis._rio?.depend();\n\tif (key === undefined) return this._locked;\t// Key-set locked\n\tkey = this.#wrapKey(key);\n\tif (this._locked && !Object.hasOwn(this._storage, key)) return true;\n\treturn !Object.getOwnPropertyDescriptor(this._storage, key)?.writable;\n    }\n\n    // Is a key/value redacted?\n    isRedacted (key) {\n\tthis._rio?.depend();\n\tif (this._redacted === true) return true;\n\tkey = this.#wrapKey(key);\n\tif (isIndex(key)) return this._redacted?.[0];\n\treturn this._redacted?.[key];\n    }\n\n    // Returns first key/index with matching value, or undefined; cf indexOf\n    keyOf (value) { return this.find(v => v === value)?.[0]; }\n\n    // keys iterator\n    keys () {\n\tthis._rio?.depend();\n\treturn this._keys.values();\n    }\n\n    // Returns last key/index with matchien value, or undefined; cf lastIndexOf\n    lastKeyOf (value) {\n\treturn this.findLast(v => v === value)?.[0];\n    }\n\n    // Lock specific *values* by key (doesn't affect key addition/removal)\n    lock (...keys) {\n\tif (typeof keys[0] === 'object') key = keys[0];\n\tfor (let key of keys) {\n\t    key = this.#wrapKey(key);\n\t    if (isIndex(key)) this._lockInd = true;\n\t    if (key !== undefined) Object.defineProperty(this._storage, key, {\n\t\tvalue: this.at(key), enumerable: true,\n\t\twritable: false, configurable: false\n\t    });\n\t}\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    // Lock all current (and possibly new) *values* (doesn't affect keys)\n    lockAll (andNew = false) {\n\tif (andNew) this._lockNew = true;\n\tthis.lock(this._keys.values());\n\treturn this;\n    }\n\n    // Lock the *key* set (unlocked values can still change)\n    lockKeys () {\n\tthis._locked = true;\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    // Just the named entries\n    *namedEntries () {\n\tfor (const e of this.entries()) if (!isIndex(e[0])) yield e;\n    }\n\n    // Just the named keys\n    *namedKeys () {\n\tfor (const e of this.entries()) if (!isIndex(e[0])) yield e[0];\n    }\n\n    // \"Next\" index (max index + 1); similar to array.length\n    get next () {\n\tthis._rio?.depend();\n\treturn this._next;\n    }\n    set next (nn) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot set next after locking');\n\tif (!Number.isInteger(nn) || nn < 0) return;\n\tfor (let i = this._next; --i >= nn; this.delete(i));\n\tif (this._next !== nn) {\n\t    this._next = nn;\n\t    this._rio?.changed();\n\t}\n    }\n\n    pairs (compact = false) {\n\treturn [...this.entries(compact)].flat(1);\n    }\n\n    // Like Array.pop (only applies to indexed values)\n    pop () {\n\tif (this._locked) throw new TypeError('NANOS: Cannot pop after locking');\n\tif (this._lockInd) throw new TypeError('NANOS: Cannot pop after index lock');\n\tif (!this._next) return undefined;\n\treturn this.delete(--this._next);\n    }\n\n    /*\n     * When pushing an object (array, NANOS, object), named keys are set\n     * directly and index keys are appended as an offset from _next\n     * (therefore preserving any gaps).\n     * Push [ object ] to add the actual object itself.\n     */\n    push (...items) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot push after locking');\n\tconst batch = this._rio?.batch || (cb => cb());\n\tbatch(() => items.forEach(value => {\n\t    const base = this._next;\n\t    if (value instanceof NANOS) {\n\t\tfor (const e of value.entries()) {\n\t\t    if (isIndex(e[0])) this.set(base + parseInt(e[0], 10), e[1]);\n\t\t    else this.set(e[0], e[1]);\n\t\t}\n\t    } else if (typeof value === 'object') {\n\t\tfor (const k of Object.keys(value)) {\n\t\t    if (isIndex(k)) this.set(base + parseInt(k, 10), value[k]);\n\t\t    else this.set(k, value[k]);\n\t\t}\n\t    } else this.set(this._next, value);\n\t}));\n\treturn this;\n    }\n\n    // NOTE: Only affects value returned by toString()\n    redact (...keys) {\n\tfor (const key of keys) {\n\t    if (key === true) this._redacted = true;\n\t    if (this._redacted === true) return;\n\t    this._redacted ||= {};\n\t    if (isIndex(key)) this._redacted[0] = true;\n\t    else this._redacted[key] = true;\n\t}\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    #renumber (from, to, by) {\n\tconst move = (k, by) => {\n\t    if (Object.hasOwn(this._storage, k)) {\n\t\tthis._storage[k + by] = this._storage[k];\n\t\tdelete this._storage[k];\n\t    }\n\t};\n\n\tif (by > 0) {\n\t    if (to + by > this._next) this._next = to + by;\n\t    for (let k = to; --k >= from; ) move(k, by);\n\t} else if (by < 0) {\n\t    if (to >= this._next) this._next += by;\n\t    for (let k = from; k < to; ++k) move(k, by);\n\t}\n\tif (by) this._keys = this._keys.map(key => {\n\t    const ind = isIndex(key) && parseInt(key, 10);\n\t    if (ind !== false && ind >= from && ind < to) return ind + by + '';\n\t    return key;\n\t});\n    }\n\n    // Reverse *in place*\n    reverse () {\n\tif (this._locked) throw new TypeError('NANOS: Cannot reverse after locking');\n\tconst s = this._storage, nks = [], ns = {}, last = this._next - 1;\n\tfor (const ok of this._keys.toReversed()) {\n\t    const nk = isIndex(ok) ? (last - ok) : ok;\n\t    ns[nk] = s[ok];\n\t    nks.push(nk);\n\t}\n\tthis._storage = ns;\n\tthis._keys = nks;\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    // Get/set reactive-interface object\n    get rio () { return this._rio; }\n\n    set rio (r) {\n\tif (!r) delete this._rio;\n\telse if ((r?.batch && r.changed && r.create && r.depend)) this._rio = r;\n    }\n\n    /*\n     * If the key is undefined, the next sequential index is used.\n     * New keys are added in the first (insert true) or last (insert false)\n     * possible position that maintain increasing-index ordering constraints.\n     */\n    set (key, value, insert = false) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot set after locking');\n\tif (key === undefined) key = this._next;\n\tkey = this.#wrapKey(key);\n\tif (key === undefined) return;\n\tconst skey = '' + key;\n\tconst ind = isIndex(skey) && parseInt(skey, 10);\n\tlet changed = false;\n\tif (!Object.hasOwn(this._storage, skey)) {\n\t    changed = true;\n\t    if (insert) {\n\t\tif (ind === false || !this._next) this._keys.unshift(skey);\n\t\telse {\n\t\t    let ki = this._keys.length;\n\t\t    while (ki > 0 && (!isIndex(this._keys[ki - 1]) || ind < this._keys[ki - 1])) --ki;\n\t\t    this._keys.splice(ki, 0, skey);\n\t\t}\n\t    } else { // append\n\t\tif (ind === false || ind >= this._next) this._keys.push(skey);\n\t\telse {\n\t\t    let ki = 0;\n\t\t    while (ki < this._keys.length && (!isIndex(this._keys[ki]) || ind > this._keys[ki])) ++ki;\n\t\t    this._keys.splice(ki, 0, skey);\n\t\t}\n\t    }\n\t    if (ind !== false && ind >= this._next) this._next = ind + 1;\n\t}\n\tif (typeof value === 'object' && this._autoPromote && value !== null) {\n\t    switch (value?.constructor?.name) {\n\t    case undefined:\n\t    case 'Array':\n\t    case 'Object':\n\t\tthis._storage[skey] = this.similar(value);\n\t\tbreak;\n\t    default:\n\t\tthis._storage[skey] = value;\n\t\tbreak;\n\t    }\n\t} else this._storage[skey] = value;\n\tif (this._lockNew) this.lock(skey);\n\tif (changed) this._rio?.changed();\n\treturn value;\n    }\n\n    setAutoPromote (v) {\n\tthis._autoPromote = v;\n\treturn this;\n    }\n\n    setRIO (r) {\n\tthis.rio = r;\n\treturn this;\n    }\n\n    // Like Array.shift (only applies to indexed values)\n    shift () {\n\tif (this._locked) throw new TypeError('NANOS: Cannot shift after locking');\n\tif (this._lockInd) throw new TypeError('NANOS: Cannot shift after index lock');\n\tif (!this._next) return undefined;\n\tconst batch = this._rio?.batch || (cb => cb());\n\treturn batch(() => {\n\t    const res = this.delete(0);\n\t    this.#renumber(1, this._next, -1);\n\t    return res;\n\t});\n    }\n\n    // Size of list (# of keys / indexes)\n    get size () {\n\tthis._rio?.depend();\n\treturn this._keys.length;\n    }\n\n    // Return a similarly-configured new NANOS\n    similar (...items) {\n\tconst nn = new NANOS();\n\tif (this._autoPromote) nn.autoPromote = true;\n\tnn.rio = this._rio?.create();\n\tif (items.length) nn.push(...items);\n\treturn nn;\n    }\n\n    get storage () {\n\tthis._rio?.depend();\n\treturn this._storage;\n    }\n\n    toReversed () {\n\tthis._rio?.depend();\n\treturn this.similar().fromPairs(this.toJSON()).reverse();\n    }\n\n    // Might be the best we can do\n    toJSON () {\n\tthis._rio?.depend();\n\treturn {type:'@NANOS@', next: this._next, pairs: this.pairs(true)};\n    }\n\n    // Generate SLID (SysCL List Data)-format string\n    toSLID ({ compact = false, redact = false } = {}) {\n\tthis._rio?.depend();\n\tconst escape = str => escapeJSString(str).replace(/\\)]/g, ')\\\\]');\n\tfunction squished (items) {\n\t    const parts = [];\n\t    for (const item of items) {\n\t\tconst tail = parts.length ? parts.slice(-1).slice(-1) : '';\n\t\tconst joint = tail + (item[0] || '')/* head */;\n\t\tif (tail && !/['\"\\[\\]]/.test(joint)) parts.push(' ');\n\t\tparts.push(item);\n\t    }\n\t    return parts.join('');\n\t}\n\tfunction valueToStr (value) {\n\t    switch (value) {\n\t    case false: return '@f';\n\t    case null: return '@n';\n\t    case true: return '@t';\n\t    case undefined: return '@u';\n\t    }\n\t    switch (typeof value) {\n\t    case 'bigint': return value.toString() + 'n';\n\t    case 'number': return value.toString();\n\t    case 'string':\n\t\t// Word-literal or quoted string\n\t\tif (/^[!()*.,:;<>?A-Z{}_][!()*.,0-9:;<>?@A-Z{}_-]*$/i.test(value)) return value;\n\t\treturn \"'\" + escape(value) + \"'\";\n\t    }\n\t    if (value instanceof NANOS) return '[' + itemsToStr(value) + ']';\n\t    return '@u/*??*/';\n\t};\n\tfunction itemsToStr (node) {\n\t    let expInd = 0;\t\t\t// Expected next index\n\t    if (redact && node._redacted === true) return ((redact === 'comment') ? '/*???*/' : '');\n\t    const items = [];\n\t    for (const en of node.entries()) {\n\t\tif (isIndex(en[0])) {\n\t\t    if (redact && node.isRedacted(0)) {\n\t\t\tif (redact === 'comment') items.push('/*?*/');\n\t\t\tcontinue;\n\t\t    }\n\t\t    const ind = parseInt(en[0], 10);\n\t\t    items.push(((ind === expInd) ? '' : `${ind}=`) + valueToStr(en[1]));\n\t\t    expInd = ind + 1;\n\t\t} else {\n\t\t    if (redact && node.isRedacted(en[0])) {\n\t\t\tif (redact === 'comment') items.push('/*?=?*/');\n\t\t    } else items.push(valueToStr(en[0]) + '=' + valueToStr(en[1]));\n\t\t}\n\t    }\n\t    return (compact ? squished(items) : items.join(' '));\n\t};\n\treturn '[(' + itemsToStr(this).replace(/\\)\\]/g, ')\\\\]') + ')]';\n    }\n\n    toString (options = {}) {\n\treturn this.toSLID({ redact: true, ...options });\n    }\n\n    /*\n     * Unshift works like push, except that indexed values are offset-from-0\n     * inserted instead (therefore preserving any gaps).\n     */\n    unshift (...items) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot unshift after locking');\n\tif (this._lockInd) throw new TypeError('NANOS: Cannot unshift after index lock');\n\tconst batch = this._rio?.batch || (cb => cb());\n\tbatch(() => items.toReversed().forEach(value => {\n\t    if (value instanceof NANOS) {\n\t\tthis.#renumber(0, this._next, value.next);\n\t\tthis.fromEntries(value.entries(), true);\n\t    } else if (typeof value === 'object') {\n\t\tconst next = Array.isArray(value) ? value.length : Object.keys(value).filter(k => isIndex(k)).reduce((acc, cur) => Math.max(acc, cur), -1) + 1;\n\t\tthis.#renumber(0, this._next, next);\n\t\tthis.fromEntries(Object.entries(value), true);\n\t    } else this.unshift([value]);\n\t}));\n\treturn this;\n    }\n\n    // Return a (non-sparse) iterator of *indexed* values [0.._next-1]\n    *values () {\n\tthis._rio?.depend();\n\tfor (let i = 0; i < this._next; ++i) yield this.at(i);\n    }\n\n    #wrapKey (key) {\n\tif (isNegIndex(key)) {\n\t    key = parseInt(key, 10) + this._next;\n\t    if (key < 0) return;\n\t}\n\treturn key;\n    }\n}\n\n// Alias .get() to .at()\nNANOS.prototype.get = NANOS.prototype.at;\n\nexport { NANOS as default };\n\n//////////////////////////////////////////////////////////////////////\n// SLID Parsing Section\n//////////////////////////////////////////////////////////////////////\n\n// SysCL List Data lexical token regexps\nconst slidPats = {\n    mlc: '/\\\\*.*?\\\\*/',\t\t// Multi-line comment\n    num: '[+-]?(?:0[bBoOxX])?[0-9]+(?:\\\\.[0-9]+)?(?:[eE][+-]?[0-9]+|n)?(?![0-9a-zA-Z])',\n    sqs: \"'(?:\\\\\\\\'|[^'])*'\",\t// Single-quoted string\n    dqs: '\"(?:\\\\\\\\\"|[^\"])*\"',\t// Double-quoted string\n    stok: '[[=\\\\]]',\t\t// Special tokens\n    spc: '\\\\s+',\t\t// Space\n    oth: '[^\\'\"/[=\\\\]\\\\s]+',\t// Other\n};\nconst slidRE = new RegExp('(' + 'mlc num sqs dqs stok spc oth'.split(' ').map(k => slidPats[k]).join('|') + ')', 's');\nconst slidNum = new RegExp('^' + slidPats.num + '$');\n\n// Parse SLID-format data, returning (potentially nested) NANOS\nexport function parseSLID (str, qj = false) {\n    let match = str.match(/\\[\\((.*?)\\)\\]/s);\n    if (!match) throw new SyntaxError('SLID boundary marker(s) not found');\n    const tokens = match[1].replace(/\\)\\\\\\]/g, ')]').split(slidRE).filter(t => !/^(\\s*|\\/\\*.*\\*\\/)$/.test(t));\n    match = undefined;\n    const parseLeft = () => {\t// Can be left of = (numbers, strings)\n\tconst token = tokens.shift();\n\tif (slidNum.test(token)) {\n\t    if (/n$/i.test(token)) return BigInt(token.slice(0, -1));\n\t    if (/^[+-]?0b/i.test(token)) return parseInt(token.replace(/0b/i, ''), 2);\n\t    if (/^[+-]?0o/i.test(token)) return parseInt(token.replace(/0o/i, ''), 8);\n\t    if (/^[+-]?0x/i.test(token)) return parseInt(token.replace(/0x/i, ''), 16);\n\t    return parseFloat(token);\n\t}\n\tif (token[0] !== \"'\" && token[0] !== '\"') return token;\n\treturn unescapeJSString(token.slice(1, -1));\n    }\n    const parseRight = () => {\t// More that can be right of =\n\tif (tokens[0] !== '[') {\n\t    if (!qj) switch (tokens[0]) {// Special values\n\t    case '@f': tokens.shift(); return false;\n\t    case '@n': tokens.shift(); return null;\n\t    case '@t': tokens.shift(); return true;\n\t    case '@u': tokens.shift(); return undefined;\n\t    }\n\t    return parseLeft();\t// Everything OK on the left\n\t}\n\ttokens.shift();\n\treturn parseItems();\t// Nested lists\n    }\n    function parseItems () {\n\tconst result = new NANOS();\n\twhile (tokens.length && tokens[0] !== ']') {\n\t    let key;\t\t\t// Default: positional\n\t    if (tokens[1] === '=') {\t// Named value\n\t\tkey = parseLeft();\n\t\ttokens.shift();\n\t    } else if (!qj && tokens[0] === '@e') {\t// Empty\n\t\ttokens.shift();\n\t\t++result.next;\n\t\tcontinue;\n\t    }\n\t    result.set(key, parseRight());\n\t}\n\tif (tokens[0] === ']') tokens.shift();\n\treturn result;\n    }\n    const result = parseItems();\n    // SLID was malformed if any tokens are left\n    if (tokens.length) throw new SyntaxError('Malformed SLID');\n    return result;\n}\n\n// Parse relaxed, \"quasi-JSON\" (by way of SLID)\nconst qjMap = { '{': '[', '}': ']', ',': ' ', ':': '=' };\nexport function parseQJSON (str) {\n    return parseSLID('[(' + str.replaceAll(/^\\s*[\\[\\{]?|[\\]\\}]\\s*$/g, '')\n      .split(/(\"(?:\\\\\\\\\"|[^\"])*\")/)\n      .map(s => (s[0] === '\"') ? s : s.replace(/[{},:]/g, c => qjMap[c]))\n      .join('') + ')]', true);\n}\n\n// END\n"],"names":["isIndex","key","test","isNegIndex","NANOS","constructor","items","this","clear","push","at","defVal","_rio","depend","wrapKey","Object","hasOwn","_storage","autoPromote","_autoPromote","v","_locked","TypeError","_next","_keys","_lockInd","undefined","_redacted","changed","skey","ret","filter","k","entries","compact","ik","parseInt","f","fromEntries","kv","find","s","findLast","toReversed","forEach","insert","batch","cb","e","reverse","set","fromPairs","pairs","type","next","Array","isArray","end","length","i","has","includes","value","keyOf","indexEntries","indexKeys","isLocked","getOwnPropertyDescriptor","writable","isRedacted","keys","values","lastKeyOf","lock","defineProperty","enumerable","configurable","lockAll","andNew","_lockNew","lockKeys","namedEntries","namedKeys","nn","Number","isInteger","delete","flat","pop","base","redact","renumber","from","to","by","move","map","ind","nks","ns","last","ok","nk","rio","r","create","ki","splice","unshift","name","similar","setAutoPromote","setRIO","shift","res","size","storage","toJSON","toSLID","valueToStr","toString","escapeJSString","replace","itemsToStr","node","expInd","en","parts","item","tail","slice","joint","join","squished","options","reduce","acc","cur","Math","max","prototype","get","slidPats","mlc","num","sqs","dqs","stok","spc","oth","slidRE","RegExp","split","slidNum","parseSLID","str","qj","match","SyntaxError","tokens","t","parseLeft","token","BigInt","parseFloat","unescapeJSString","parseRight","parseItems","result","qjMap","parseQJSON","replaceAll","c"],"mappings":"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"}