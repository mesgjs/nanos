{
  "version": 3,
  "sources": ["../src/nanos.esm.js"],
  "sourcesContent": ["/*\n * NANOS - Named and numbered ordered storage\n * Copyright 2024-2025 by Kappa Computer Solutions, LLC and Brian Katzung\n * Author: Brian Katzung <briank@kappacs.com>\n */\n\nimport { escapeJSString, unescapeJSString } from './vendor/escape-js.esm.js';\n\nexport const isIndex = key => /^(?:0|[1-9]\\d*)$/.test(key);\nexport const isNegIndex = key => /^-[1-9]\\d*$/.test(key);\n\nexport class NANOS {\n    constructor (...items) {\n\tthis.clear();\n\tthis.push(...items);\n    }\n\n    // Get value at key or index (negative index relative to end)\n    at (key, defVal) {\n\tthis._rio?.depend();\n\tkey = this.#wrapKey(key);\n\treturn Object.hasOwn(this._storage, key) ? this._storage[key] : defVal;\n    }\n\n    get autoPromote () { return this._autoPromote; }\n\n    set autoPromote (v) { this._autoPromote = v; }\n\n    clear () {\n\tif (this._locked) throw new TypeError('NANOS: Cannot clear after locking');\n\tthis._next = 0;\n\tthis._keys = [];\n\tthis._storage = {};\n\tthis._lockInd = undefined;\n\tdelete this._redacted;\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    // NOTE: unlike the delete statement, this returns the deleted value!\n    delete (key) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot delete after locking');\n\tconst skey = '' + key;\n\tconst ret = this._storage[skey];\n\tif (Object.hasOwn(this._storage, skey)) {\n\t    delete this._storage[skey];\n\t    this._keys = this._keys.filter(k => k !== skey);\n\t    this._rio?.changed();\n\t}\n\treturn ret;\n    }\n\n    depend () { this._rio?.depend(); }\n\n    /*\n     * Returns [ [ key1, value1 ], ... [ keyN, valueN ] ]\n     * Compact mode uses numeric index keys instead of the standard strings\n     * (e.g. 0 instead of '0').\n     */\n    *entries (compact = false) {\n\tthis._rio?.depend();\n\tconst ik = compact ? (k => isIndex(k) ? parseInt(k, 10) : k) : (k => k);\n\tfor (const k of this._keys) yield [ ik(k), this._storage[k] ];\n    }\n\n    // Returns a shallow copy of elements for which f(value, key) is true\n    filter (f) {\n\tthis._rio?.depend();\n\treturn new NANOS.fromEntries([...this.entries()].filter(kv => f(kv[1], kv[0], this)));\n    }\n\n    // Returns first [key, value] where f(value, key) is true; cf find, findIndex\n    find (f) {\n\tthis._rio?.depend();\n\tconst s = this._storage;\n\tfor (const k of this._keys) if (f(s[k], k, this)) return [k, s[k]];\n    }\n\n    // Returns last [key, value] where f(value, key) is true; cf findLast, findLastIndex\n    findLast (f) {\n\tthis._rio?.depend();\n\tconst s = this._storage;\n\tfor (const k of this._keys.toReversed()) if (f(s[k], k, this)) return [k, s[k]];\n    }\n\n    forEach (f) {\n\tthis._rio?.depend();\n\tfor (const k of this._keys) f(this._storage[k], k, this);\n    }\n\n    // [ [ key1, value1 ], ... [ keyN, valueN ] ]\n    fromEntries (entries, insert = false) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot fromEntries after locking');\n\tif (insert && this._lockInd) throw new TypeError('NANOS: Cannot insert fromEntries after index lock');\n\tconst batch = this._rio?.batch || (cb => cb());\n\tbatch(() => {\n\t    if (insert) for (const e of [...entries].reverse()) this.set(e[0], e[1], true);\n\t    else for (const e of entries) this.set(e[0], e[1]);\n\t    this._rio?.changed();\n\t});\n\treturn this;\n    }\n\n    /*\n     * [ key1, value1, ... keyN, valueN ]\n     * { type: '@NANOS@', next, pairs }\n     */\n    fromPairs (...pairs) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot fromPairs after locking');\n\tconst batch = this._rio?.batch || (cb => cb());\n\tif (pairs[0]?.type === '@NANOS@') {\n\t    batch(() => {\n\t\tthis.fromPairs(pairs[0].pairs);\n\t\tthis.next = pairs[0].next;\n\t\tthis._rio?.changed();\n\t    });\n\t    return this;\n\t}\n\tif (Array.isArray(pairs[0])) pairs = pairs[0];\n\tconst end = pairs.length - 1;\n\tbatch(() => {\n\t    for (let i = 0; i < end; i += 2) {\n\t\tif (pairs[i] === undefined && !(i + 1 in pairs)) ++this._next;\n\t\telse this.set(pairs[i], pairs[i + 1]);\n\t    }\n\t    this._rio?.changed();\n\t});\n\treturn this;\n    }\n\n    // Instead of \"key in NANOS\"\n    has (key) {\n\tthis._rio?.depend();\n\treturn Object.hasOwn(this._storage, this.#wrapKey(key));\n    }\n\n    includes (value) {\n\treturn this.keyOf(value) !== undefined;\n    }\n\n    // Just the index entries\n    *indexEntries (compact = false) {\n\tfor (const e of this.entries(compact)) if (isIndex(e[0])) yield e;\n    }\n\n    // Just the index keys\n    *indexKeys () {\n\tthis._rio?.depend();\n\tfor (const k of this._keys) if (isIndex(k)) yield k;\n    }\n\n    // Is a key/value (or, if undef, the key-set) locked?\n    isLocked (key) {\n\tthis._rio?.depend();\n\tif (key === undefined) return this._locked;\t// Key-set locked\n\tkey = this.#wrapKey(key);\n\tif (this._locked && !Object.hasOwn(this._storage, key)) return true;\n\treturn !Object.getOwnPropertyDescriptor(this._storage, key)?.writable;\n    }\n\n    // Is a key/value redacted?\n    isRedacted (key) {\n\tthis._rio?.depend();\n\tif (this._redacted === true) return true;\n\tkey = this.#wrapKey(key);\n\tif (isIndex(key)) return this._redacted?.[0];\n\treturn this._redacted?.[key];\n    }\n\n    // Returns first key/index with matching value, or undefined; cf indexOf\n    keyOf (value) { return this.find(v => v === value)?.[0]; }\n\n    // keys iterator\n    keys () {\n\tthis._rio?.depend();\n\treturn this._keys.values();\n    }\n\n    // Returns last key/index with matchien value, or undefined; cf lastIndexOf\n    lastKeyOf (value) {\n\treturn this.findLast(v => v === value)?.[0];\n    }\n\n    // Lock specific *values* by key (doesn't affect key addition/removal)\n    lock (...keys) {\n\tif (typeof keys[0] === 'object') key = keys[0];\n\tfor (let key of keys) {\n\t    key = this.#wrapKey(key);\n\t    if (isIndex(key)) this._lockInd = true;\n\t    if (key !== undefined) Object.defineProperty(this._storage, key, {\n\t\tvalue: this.at(key), enumerable: true,\n\t\twritable: false, configurable: false\n\t    });\n\t}\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    // Lock all current (and possibly new) *values* (doesn't affect keys)\n    lockAll (andNew = false) {\n\tif (andNew) this._lockNew = true;\n\tthis.lock(this._keys.values());\n\treturn this;\n    }\n\n    // Lock the *key* set (unlocked values can still change)\n    lockKeys () {\n\tthis._locked = true;\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    // Just the named entries\n    *namedEntries () {\n\tfor (const e of this.entries()) if (!isIndex(e[0])) yield e;\n    }\n\n    // Just the named keys\n    *namedKeys () {\n\tfor (const e of this.entries()) if (!isIndex(e[0])) yield e[0];\n    }\n\n    // \"Next\" index (max index + 1); similar to array.length\n    get next () {\n\tthis._rio?.depend();\n\treturn this._next;\n    }\n    set next (nn) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot set next after locking');\n\tif (!Number.isInteger(nn) || nn < 0) return;\n\tfor (let i = this._next; --i >= nn; this.delete(i));\n\tif (this._next !== nn) {\n\t    this._next = nn;\n\t    this._rio?.changed();\n\t}\n    }\n\n    pairs (compact = false) {\n\treturn [...this.entries(compact)].flat(1);\n    }\n\n    // Like Array.pop (only applies to indexed values)\n    pop () {\n\tif (this._locked) throw new TypeError('NANOS: Cannot pop after locking');\n\tif (this._lockInd) throw new TypeError('NANOS: Cannot pop after index lock');\n\tif (!this._next) return undefined;\n\treturn this.delete(--this._next);\n    }\n\n    /*\n     * When pushing an object (array, NANOS, object), named keys are set\n     * directly and index keys are appended as an offset from _next\n     * (therefore preserving any gaps).\n     * Push [ object ] to add the actual object itself.\n     */\n    push (...items) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot push after locking');\n\tconst batch = this._rio?.batch || (cb => cb());\n\tbatch(() => items.forEach(value => {\n\t    const base = this._next;\n\t    if (value instanceof NANOS) {\n\t\tfor (const e of value.entries()) {\n\t\t    if (isIndex(e[0])) this.set(base + parseInt(e[0], 10), e[1]);\n\t\t    else this.set(e[0], e[1]);\n\t\t}\n\t    } else if (typeof value === 'object') {\n\t\tfor (const k of Object.keys(value)) {\n\t\t    if (isIndex(k)) this.set(base + parseInt(k, 10), value[k]);\n\t\t    else this.set(k, value[k]);\n\t\t}\n\t    } else this.set(this._next, value);\n\t}));\n\treturn this;\n    }\n\n    // NOTE: Only affects value returned by toString()\n    redact (...keys) {\n\tfor (const key of keys) {\n\t    if (key === true) this._redacted = true;\n\t    if (this._redacted === true) return;\n\t    this._redacted ||= {};\n\t    if (isIndex(key)) this._redacted[0] = true;\n\t    else this._redacted[key] = true;\n\t}\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    #renumber (from, to, by) {\n\tconst move = (k, by) => {\n\t    if (Object.hasOwn(this._storage, k)) {\n\t\tthis._storage[k + by] = this._storage[k];\n\t\tdelete this._storage[k];\n\t    }\n\t};\n\n\tif (by > 0) {\n\t    if (to + by > this._next) this._next = to + by;\n\t    for (let k = to; --k >= from; ) move(k, by);\n\t} else if (by < 0) {\n\t    if (to >= this._next) this._next += by;\n\t    for (let k = from; k < to; ++k) move(k, by);\n\t}\n\tif (by) this._keys = this._keys.map(key => {\n\t    const ind = isIndex(key) && parseInt(key, 10);\n\t    if (ind !== false && ind >= from && ind < to) return ind + by + '';\n\t    return key;\n\t});\n    }\n\n    // Reverse *in place*\n    reverse () {\n\tif (this._locked) throw new TypeError('NANOS: Cannot reverse after locking');\n\tconst s = this._storage, nks = [], ns = {}, last = this._next - 1;\n\tfor (const ok of this._keys.toReversed()) {\n\t    const nk = isIndex(ok) ? (last - ok) : ok;\n\t    ns[nk] = s[ok];\n\t    nks.push(nk);\n\t}\n\tthis._storage = ns;\n\tthis._keys = nks;\n\tthis._rio?.changed();\n\treturn this;\n    }\n\n    // Get/set reactive-interface object\n    get rio () { return this._rio; }\n\n    set rio (r) {\n\tif (!r) delete this._rio;\n\telse if ((r?.batch && r.changed && r.create && r.depend)) this._rio = r;\n    }\n\n    /*\n     * If the key is undefined, the next sequential index is used.\n     * New keys are added in the first (insert true) or last (insert false)\n     * possible position that maintain increasing-index ordering constraints.\n     */\n    set (key, value, insert = false) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot set after locking');\n\tif (key === undefined) key = this._next;\n\tkey = this.#wrapKey(key);\n\tif (key === undefined) return;\n\tconst skey = '' + key;\n\tconst ind = isIndex(skey) && parseInt(skey, 10);\n\tlet changed = false;\n\tif (!Object.hasOwn(this._storage, skey)) {\n\t    changed = true;\n\t    if (insert) {\n\t\tif (ind === false || !this._next) this._keys.unshift(skey);\n\t\telse {\n\t\t    let ki = this._keys.length;\n\t\t    while (ki > 0 && (!isIndex(this._keys[ki - 1]) || ind < this._keys[ki - 1])) --ki;\n\t\t    this._keys.splice(ki, 0, skey);\n\t\t}\n\t    } else { // append\n\t\tif (ind === false || ind >= this._next) this._keys.push(skey);\n\t\telse {\n\t\t    let ki = 0;\n\t\t    while (ki < this._keys.length && (!isIndex(this._keys[ki]) || ind > this._keys[ki])) ++ki;\n\t\t    this._keys.splice(ki, 0, skey);\n\t\t}\n\t    }\n\t    if (ind !== false && ind >= this._next) this._next = ind + 1;\n\t}\n\tif (typeof value === 'object' && this._autoPromote && value !== null) {\n\t    switch (value?.constructor?.name) {\n\t    case undefined:\n\t    case 'Array':\n\t    case 'Object':\n\t\tthis._storage[skey] = this.similar(value);\n\t\tbreak;\n\t    default:\n\t\tthis._storage[skey] = value;\n\t\tbreak;\n\t    }\n\t} else this._storage[skey] = value;\n\tif (this._lockNew) this.lock(skey);\n\tif (changed) this._rio?.changed();\n\treturn value;\n    }\n\n    setAutoPromote (v) {\n\tthis._autoPromote = v;\n\treturn this;\n    }\n\n    setRIO (r) {\n\tthis.rio = r;\n\treturn this;\n    }\n\n    // Like Array.shift (only applies to indexed values)\n    shift () {\n\tif (this._locked) throw new TypeError('NANOS: Cannot shift after locking');\n\tif (this._lockInd) throw new TypeError('NANOS: Cannot shift after index lock');\n\tif (!this._next) return undefined;\n\tconst batch = this._rio?.batch || (cb => cb());\n\treturn batch(() => {\n\t    const res = this.delete(0);\n\t    this.#renumber(1, this._next, -1);\n\t    return res;\n\t});\n    }\n\n    // Size of list (# of keys / indexes)\n    get size () {\n\tthis._rio?.depend();\n\treturn this._keys.length;\n    }\n\n    // Return a similarly-configured new NANOS\n    similar (...items) {\n\tconst nn = new NANOS();\n\tif (this._autoPromote) nn.autoPromote = true;\n\tnn.rio = this._rio?.create();\n\tif (items.length) nn.push(...items);\n\treturn nn;\n    }\n\n    get storage () {\n\tthis._rio?.depend();\n\treturn this._storage;\n    }\n\n    toReversed () {\n\tthis._rio?.depend();\n\treturn this.similar().fromPairs(this.toJSON()).reverse();\n    }\n\n    // Might be the best we can do\n    toJSON () {\n\tthis._rio?.depend();\n\treturn {type:'@NANOS@', next: this._next, pairs: this.pairs(true)};\n    }\n\n    // Generate SLID (SysCL List Data)-format string\n    toSLID ({ compact = false, redact = false } = {}) {\n\tthis._rio?.depend();\n\tconst escape = str => escapeJSString(str).replace(/\\)]/g, ')\\\\]');\n\tfunction squished (items) {\n\t    const parts = [];\n\t    for (const item of items) {\n\t\tconst tail = parts.length ? parts.slice(-1).slice(-1) : '';\n\t\tconst joint = tail + (item[0] || '')/* head */;\n\t\tif (tail && !/['\"\\[\\]]/.test(joint)) parts.push(' ');\n\t\tparts.push(item);\n\t    }\n\t    return parts.join('');\n\t}\n\tfunction valueToStr (value) {\n\t    switch (value) {\n\t    case false: return '@f';\n\t    case null: return '@n';\n\t    case true: return '@t';\n\t    case undefined: return '@u';\n\t    }\n\t    switch (typeof value) {\n\t    case 'bigint': return value.toString() + 'n';\n\t    case 'number': return value.toString();\n\t    case 'string':\n\t\t// Word-literal or quoted string\n\t\tif (/^[!()*.,:;<>?A-Z{}_][!()*.,0-9:;<>?@A-Z{}_-]*$/i.test(value)) return value;\n\t\treturn \"'\" + escape(value) + \"'\";\n\t    }\n\t    if (value instanceof NANOS) return '[' + itemsToStr(value) + ']';\n\t    return '@u/*??*/';\n\t};\n\tfunction itemsToStr (node) {\n\t    let expInd = 0;\t\t\t// Expected next index\n\t    if (redact && node._redacted === true) return ((redact === 'comment') ? '/*???*/' : '');\n\t    const items = [];\n\t    for (const en of node.entries()) {\n\t\tif (isIndex(en[0])) {\n\t\t    if (redact && node.isRedacted(0)) {\n\t\t\tif (redact === 'comment') items.push('/*?*/');\n\t\t\tcontinue;\n\t\t    }\n\t\t    const ind = parseInt(en[0], 10);\n\t\t    items.push(((ind === expInd) ? '' : `${ind}=`) + valueToStr(en[1]));\n\t\t    expInd = ind + 1;\n\t\t} else {\n\t\t    if (redact && node.isRedacted(en[0])) {\n\t\t\tif (redact === 'comment') items.push('/*?=?*/');\n\t\t    } else items.push(valueToStr(en[0]) + '=' + valueToStr(en[1]));\n\t\t}\n\t    }\n\t    return (compact ? squished(items) : items.join(' '));\n\t};\n\treturn '[(' + itemsToStr(this).replace(/\\)\\]/g, ')\\\\]') + ')]';\n    }\n\n    toString (options = {}) {\n\treturn this.toSLID({ redact: true, ...options });\n    }\n\n    /*\n     * Unshift works like push, except that indexed values are offset-from-0\n     * inserted instead (therefore preserving any gaps).\n     */\n    unshift (...items) {\n\tif (this._locked) throw new TypeError('NANOS: Cannot unshift after locking');\n\tif (this._lockInd) throw new TypeError('NANOS: Cannot unshift after index lock');\n\tconst batch = this._rio?.batch || (cb => cb());\n\tbatch(() => items.toReversed().forEach(value => {\n\t    if (value instanceof NANOS) {\n\t\tthis.#renumber(0, this._next, value.next);\n\t\tthis.fromEntries(value.entries(), true);\n\t    } else if (typeof value === 'object') {\n\t\tconst next = Array.isArray(value) ? value.length : Object.keys(value).filter(k => isIndex(k)).reduce((acc, cur) => Math.max(acc, cur), -1) + 1;\n\t\tthis.#renumber(0, this._next, next);\n\t\tthis.fromEntries(Object.entries(value), true);\n\t    } else this.unshift([value]);\n\t}));\n\treturn this;\n    }\n\n    // Return a (non-sparse) iterator of *indexed* values [0.._next-1]\n    *values () {\n\tthis._rio?.depend();\n\tfor (let i = 0; i < this._next; ++i) yield this.at(i);\n    }\n\n    #wrapKey (key) {\n\tif (isNegIndex(key)) {\n\t    key = parseInt(key, 10) + this._next;\n\t    if (key < 0) return;\n\t}\n\treturn key;\n    }\n}\n\n// Alias .get() to .at()\nNANOS.prototype.get = NANOS.prototype.at;\n\nexport { NANOS as default };\n\n//////////////////////////////////////////////////////////////////////\n// SLID Parsing Section\n//////////////////////////////////////////////////////////////////////\n\n// SysCL List Data lexical token regexps\nconst slidPats = {\n    mlc: '/\\\\*.*?\\\\*/',\t\t// Multi-line comment\n    num: '[+-]?(?:0[bBoOxX])?[0-9]+(?:\\\\.[0-9]+)?(?:[eE][+-]?[0-9]+|n)?(?![0-9a-zA-Z])',\n    sqs: \"'(?:\\\\\\\\'|[^'])*'\",\t// Single-quoted string\n    dqs: '\"(?:\\\\\\\\\"|[^\"])*\"',\t// Double-quoted string\n    stok: '[[=\\\\]]',\t\t// Special tokens\n    spc: '\\\\s+',\t\t// Space\n    oth: '[^\\'\"/[=\\\\]\\\\s]+',\t// Other\n};\nconst slidRE = new RegExp('(' + 'mlc num sqs dqs stok spc oth'.split(' ').map(k => slidPats[k]).join('|') + ')', 's');\nconst slidNum = new RegExp('^' + slidPats.num + '$');\n\n// Parse SLID-format data, returning (potentially nested) NANOS\nexport function parseSLID (str, qj = false) {\n    let match = str.match(/\\[\\((.*?)\\)\\]/s);\n    if (!match) throw new SyntaxError('SLID boundary marker(s) not found');\n    const tokens = match[1].replace(/\\)\\\\\\]/g, ')]').split(slidRE).filter(t => !/^(\\s*|\\/\\*.*\\*\\/)$/.test(t));\n    match = undefined;\n    const parseLeft = () => {\t// Can be left of = (numbers, strings)\n\tconst token = tokens.shift();\n\tif (slidNum.test(token)) {\n\t    if (/n$/i.test(token)) return BigInt(token.slice(0, -1));\n\t    if (/^[+-]?0b/i.test(token)) return parseInt(token.replace(/0b/i, ''), 2);\n\t    if (/^[+-]?0o/i.test(token)) return parseInt(token.replace(/0o/i, ''), 8);\n\t    if (/^[+-]?0x/i.test(token)) return parseInt(token.replace(/0x/i, ''), 16);\n\t    return parseFloat(token);\n\t}\n\tif (token[0] !== \"'\" && token[0] !== '\"') return token;\n\treturn unescapeJSString(token.slice(1, -1));\n    }\n    const parseRight = () => {\t// More that can be right of =\n\tif (tokens[0] !== '[') {\n\t    if (!qj) switch (tokens[0]) {// Special values\n\t    case '@f': tokens.shift(); return false;\n\t    case '@n': tokens.shift(); return null;\n\t    case '@t': tokens.shift(); return true;\n\t    case '@u': tokens.shift(); return undefined;\n\t    }\n\t    return parseLeft();\t// Everything OK on the left\n\t}\n\ttokens.shift();\n\treturn parseItems();\t// Nested lists\n    }\n    function parseItems () {\n\tconst result = new NANOS();\n\twhile (tokens.length && tokens[0] !== ']') {\n\t    let key;\t\t\t// Default: positional\n\t    if (tokens[1] === '=') {\t// Named value\n\t\tkey = parseLeft();\n\t\ttokens.shift();\n\t    } else if (!qj && tokens[0] === '@e') {\t// Empty\n\t\ttokens.shift();\n\t\t++result.next;\n\t\tcontinue;\n\t    }\n\t    result.set(key, parseRight());\n\t}\n\tif (tokens[0] === ']') tokens.shift();\n\treturn result;\n    }\n    const result = parseItems();\n    // SLID was malformed if any tokens are left\n    if (tokens.length) throw new SyntaxError('Malformed SLID');\n    return result;\n}\n\n// Parse relaxed, \"quasi-JSON\" (by way of SLID)\nconst qjMap = { '{': '[', '}': ']', ',': ' ', ':': '=' };\nexport function parseQJSON (str) {\n    return parseSLID('[(' + str.replaceAll(/^\\s*[\\[\\{]?|[\\]\\}]\\s*$/g, '')\n      .split(/(\"(?:\\\\\\\\\"|[^\"])*\")/)\n      .map(s => (s[0] === '\"') ? s : s.replace(/[{},:]/g, c => qjMap[c]))\n      .join('') + ')]', true);\n}\n\n// END\n"],
  "mappings": "AAMA,OAAS,kBAAAA,EAAgB,oBAAAC,MAAwB,4BAE1C,MAAMC,EAAUC,GAAO,mBAAmB,KAAKA,CAAG,EAC5CC,EAAaD,GAAO,cAAc,KAAKA,CAAG,EAEhD,MAAME,CAAM,CACf,eAAgBC,EAAO,CAC1B,KAAK,MAAM,EACX,KAAK,KAAK,GAAGA,CAAK,CACf,CAGA,GAAIH,EAAKI,EAAQ,CACpB,YAAK,MAAM,OAAO,EAClBJ,EAAM,KAAKK,GAASL,CAAG,EAChB,OAAO,OAAO,KAAK,SAAUA,CAAG,EAAI,KAAK,SAASA,CAAG,EAAII,CAC7D,CAEA,IAAI,aAAe,CAAE,OAAO,KAAK,YAAc,CAE/C,IAAI,YAAaE,EAAG,CAAE,KAAK,aAAeA,CAAG,CAE7C,OAAS,CACZ,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,mCAAmC,EACzE,YAAK,MAAQ,EACb,KAAK,MAAQ,CAAC,EACd,KAAK,SAAW,CAAC,EACjB,KAAK,SAAW,OAChB,OAAO,KAAK,UACZ,KAAK,MAAM,QAAQ,EACZ,IACJ,CAGA,OAAQN,EAAK,CAChB,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,oCAAoC,EAC1E,MAAMO,EAAO,GAAKP,EACZQ,EAAM,KAAK,SAASD,CAAI,EAC9B,OAAI,OAAO,OAAO,KAAK,SAAUA,CAAI,IACjC,OAAO,KAAK,SAASA,CAAI,EACzB,KAAK,MAAQ,KAAK,MAAM,OAAOE,GAAKA,IAAMF,CAAI,EAC9C,KAAK,MAAM,QAAQ,GAEhBC,CACJ,CAEA,QAAU,CAAE,KAAK,MAAM,OAAO,CAAG,CAOjC,CAAC,QAASE,EAAU,GAAO,CAC9B,KAAK,MAAM,OAAO,EAClB,MAAMC,EAAKD,EAAWD,GAAKV,EAAQU,CAAC,EAAI,SAASA,EAAG,EAAE,EAAIA,EAAMA,GAAKA,EACrE,UAAWA,KAAK,KAAK,MAAO,KAAM,CAAEE,EAAGF,CAAC,EAAG,KAAK,SAASA,CAAC,CAAE,CACzD,CAGA,OAAQG,EAAG,CACd,YAAK,MAAM,OAAO,EACX,IAAIV,EAAM,YAAY,CAAC,GAAG,KAAK,QAAQ,CAAC,EAAE,OAAOW,GAAMD,EAAEC,EAAG,CAAC,EAAGA,EAAG,CAAC,EAAG,IAAI,CAAC,CAAC,CACjF,CAGA,KAAMD,EAAG,CACZ,KAAK,MAAM,OAAO,EAClB,MAAME,EAAI,KAAK,SACf,UAAWL,KAAK,KAAK,MAAO,GAAIG,EAAEE,EAAEL,CAAC,EAAGA,EAAG,IAAI,EAAG,MAAO,CAACA,EAAGK,EAAEL,CAAC,CAAC,CAC9D,CAGA,SAAUG,EAAG,CAChB,KAAK,MAAM,OAAO,EAClB,MAAME,EAAI,KAAK,SACf,UAAWL,KAAK,KAAK,MAAM,WAAW,EAAG,GAAIG,EAAEE,EAAEL,CAAC,EAAGA,EAAG,IAAI,EAAG,MAAO,CAACA,EAAGK,EAAEL,CAAC,CAAC,CAC3E,CAEA,QAASG,EAAG,CACf,KAAK,MAAM,OAAO,EAClB,UAAWH,KAAK,KAAK,MAAOG,EAAE,KAAK,SAASH,CAAC,EAAGA,EAAG,IAAI,CACpD,CAGA,YAAaM,EAASC,EAAS,GAAO,CACzC,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,yCAAyC,EAC/E,GAAIA,GAAU,KAAK,SAAU,MAAM,IAAI,UAAU,mDAAmD,EAEpG,OADc,KAAK,MAAM,QAAUC,GAAMA,EAAG,IACtC,IAAM,CACR,GAAID,EAAQ,UAAWE,IAAK,CAAC,GAAGH,CAAO,EAAE,QAAQ,EAAG,KAAK,IAAIG,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAG,EAAI,MACxE,WAAWA,KAAKH,EAAS,KAAK,IAAIG,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EACjD,KAAK,MAAM,QAAQ,CACvB,CAAC,EACM,IACJ,CAMA,aAAcC,EAAO,CACxB,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,uCAAuC,EAC7E,MAAMC,EAAQ,KAAK,MAAM,QAAUH,GAAMA,EAAG,GAC5C,GAAIE,EAAM,CAAC,GAAG,OAAS,UACnB,OAAAC,EAAM,IAAM,CACf,KAAK,UAAUD,EAAM,CAAC,EAAE,KAAK,EAC7B,KAAK,KAAOA,EAAM,CAAC,EAAE,KACrB,KAAK,MAAM,QAAQ,CAChB,CAAC,EACM,KAEP,MAAM,QAAQA,EAAM,CAAC,CAAC,IAAGA,EAAQA,EAAM,CAAC,GAC5C,MAAME,EAAMF,EAAM,OAAS,EAC3B,OAAAC,EAAM,IAAM,CACR,QAASE,EAAI,EAAGA,EAAID,EAAKC,GAAK,EAC7BH,EAAMG,CAAC,IAAM,QAAa,EAAEA,EAAI,KAAKH,GAAQ,EAAE,KAAK,MACnD,KAAK,IAAIA,EAAMG,CAAC,EAAGH,EAAMG,EAAI,CAAC,CAAC,EAEjC,KAAK,MAAM,QAAQ,CACvB,CAAC,EACM,IACJ,CAGA,IAAKtB,EAAK,CACb,YAAK,MAAM,OAAO,EACX,OAAO,OAAO,KAAK,SAAU,KAAKK,GAASL,CAAG,CAAC,CACnD,CAEA,SAAUuB,EAAO,CACpB,OAAO,KAAK,MAAMA,CAAK,IAAM,MAC1B,CAGA,CAAC,aAAcb,EAAU,GAAO,CACnC,UAAW,KAAK,KAAK,QAAQA,CAAO,EAAOX,EAAQ,EAAE,CAAC,CAAC,IAAG,MAAM,EAC7D,CAGA,CAAC,WAAa,CACjB,KAAK,MAAM,OAAO,EAClB,UAAWU,KAAK,KAAK,MAAWV,EAAQU,CAAC,IAAG,MAAMA,EAC/C,CAGA,SAAUT,EAAK,CAElB,OADA,KAAK,MAAM,OAAO,EACdA,IAAQ,OAAkB,KAAK,SACnCA,EAAM,KAAKK,GAASL,CAAG,EACnB,KAAK,SAAW,CAAC,OAAO,OAAO,KAAK,SAAUA,CAAG,EAAU,GACxD,CAAC,OAAO,yBAAyB,KAAK,SAAUA,CAAG,GAAG,SAC1D,CAGA,WAAYA,EAAK,CAEpB,OADA,KAAK,MAAM,OAAO,EACd,KAAK,YAAc,GAAa,IACpCA,EAAM,KAAKK,GAASL,CAAG,EACnBD,EAAQC,CAAG,EAAU,KAAK,YAAY,CAAC,EACpC,KAAK,YAAYA,CAAG,EACxB,CAGA,MAAOuB,EAAO,CAAE,OAAO,KAAK,KAAKjB,GAAKA,IAAMiB,CAAK,IAAI,CAAC,CAAG,CAGzD,MAAQ,CACX,YAAK,MAAM,OAAO,EACX,KAAK,MAAM,OAAO,CACtB,CAGA,UAAWA,EAAO,CACrB,OAAO,KAAK,SAASjB,GAAKA,IAAMiB,CAAK,IAAI,CAAC,CACvC,CAGA,QAASC,EAAM,CACd,OAAOA,EAAK,CAAC,GAAM,WAAU,IAAMA,EAAK,CAAC,GAC7C,QAASxB,KAAOwB,EACZxB,EAAM,KAAKK,GAASL,CAAG,EACnBD,EAAQC,CAAG,IAAG,KAAK,SAAW,IAC9BA,IAAQ,QAAW,OAAO,eAAe,KAAK,SAAUA,EAAK,CACpE,MAAO,KAAK,GAAGA,CAAG,EAAG,WAAY,GACjC,SAAU,GAAO,aAAc,EAC5B,CAAC,EAEL,YAAK,MAAM,QAAQ,EACZ,IACJ,CAGA,QAASyB,EAAS,GAAO,CAC5B,OAAIA,IAAQ,KAAK,SAAW,IAC5B,KAAK,KAAK,KAAK,MAAM,OAAO,CAAC,EACtB,IACJ,CAGA,UAAY,CACf,YAAK,QAAU,GACf,KAAK,MAAM,QAAQ,EACZ,IACJ,CAGA,CAAC,cAAgB,CACpB,UAAWP,KAAK,KAAK,QAAQ,EAAQnB,EAAQmB,EAAE,CAAC,CAAC,IAAG,MAAMA,EACvD,CAGA,CAAC,WAAa,CACjB,UAAWA,KAAK,KAAK,QAAQ,EAAQnB,EAAQmB,EAAE,CAAC,CAAC,IAAG,MAAMA,EAAE,CAAC,EAC1D,CAGA,IAAI,MAAQ,CACf,YAAK,MAAM,OAAO,EACX,KAAK,KACT,CACA,IAAI,KAAMQ,EAAI,CACjB,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,sCAAsC,EAC5E,GAAI,GAAC,OAAO,UAAUA,CAAE,GAAKA,EAAK,GAClC,SAASJ,EAAI,KAAK,MAAO,EAAEA,GAAKI,EAAI,KAAK,OAAOJ,CAAC,EAAE,CAC/C,KAAK,QAAUI,IACf,KAAK,MAAQA,EACb,KAAK,MAAM,QAAQ,GAEpB,CAEA,MAAOhB,EAAU,GAAO,CAC3B,MAAO,CAAC,GAAG,KAAK,QAAQA,CAAO,CAAC,EAAE,KAAK,CAAC,CACrC,CAGA,KAAO,CACV,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,iCAAiC,EACvE,GAAI,KAAK,SAAU,MAAM,IAAI,UAAU,oCAAoC,EAC3E,GAAK,KAAK,MACV,OAAO,KAAK,OAAO,EAAE,KAAK,KAAK,CAC5B,CAQA,QAASP,EAAO,CACnB,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,kCAAkC,EAExE,OADc,KAAK,MAAM,QAAUc,GAAMA,EAAG,IACtC,IAAMd,EAAM,QAAQoB,GAAS,CAC/B,MAAMI,EAAO,KAAK,MAClB,GAAIJ,aAAiBrB,EACxB,UAAWgB,KAAKK,EAAM,QAAQ,EACtBxB,EAAQmB,EAAE,CAAC,CAAC,EAAG,KAAK,IAAIS,EAAO,SAAST,EAAE,CAAC,EAAG,EAAE,EAAGA,EAAE,CAAC,CAAC,EACtD,KAAK,IAAIA,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,UAEd,OAAOK,GAAU,SAC/B,UAAWd,KAAK,OAAO,KAAKc,CAAK,EACzBxB,EAAQU,CAAC,EAAG,KAAK,IAAIkB,EAAO,SAASlB,EAAG,EAAE,EAAGc,EAAMd,CAAC,CAAC,EACpD,KAAK,IAAIA,EAAGc,EAAMd,CAAC,CAAC,OAEnB,KAAK,IAAI,KAAK,MAAOc,CAAK,CACrC,CAAC,CAAC,EACK,IACJ,CAGA,UAAWC,EAAM,CACpB,UAAWxB,KAAOwB,EAAM,CAEpB,GADIxB,IAAQ,KAAM,KAAK,UAAY,IAC/B,KAAK,YAAc,GAAM,OAC7B,KAAK,YAAc,CAAC,EAChBD,EAAQC,CAAG,EAAG,KAAK,UAAU,CAAC,EAAI,GACjC,KAAK,UAAUA,CAAG,EAAI,EAC/B,CACA,YAAK,MAAM,QAAQ,EACZ,IACJ,CAEA4B,GAAWC,EAAMC,EAAIC,EAAI,CAC5B,MAAMC,EAAO,CAACvB,EAAGsB,IAAO,CAChB,OAAO,OAAO,KAAK,SAAUtB,CAAC,IACrC,KAAK,SAASA,EAAIsB,CAAE,EAAI,KAAK,SAAStB,CAAC,EACvC,OAAO,KAAK,SAASA,CAAC,EAEvB,EAEA,GAAIsB,EAAK,EAAG,CACJD,EAAKC,EAAK,KAAK,QAAO,KAAK,MAAQD,EAAKC,GAC5C,QAAStB,EAAIqB,EAAI,EAAErB,GAAKoB,GAAQG,EAAKvB,EAAGsB,CAAE,CAC9C,SAAWA,EAAK,EAAG,CACXD,GAAM,KAAK,QAAO,KAAK,OAASC,GACpC,QAAStB,EAAIoB,EAAMpB,EAAIqB,EAAI,EAAErB,EAAGuB,EAAKvB,EAAGsB,CAAE,CAC9C,CACIA,IAAI,KAAK,MAAQ,KAAK,MAAM,IAAI/B,GAAO,CACvC,MAAMiC,EAAMlC,EAAQC,CAAG,GAAK,SAASA,EAAK,EAAE,EAC5C,OAAIiC,IAAQ,IAASA,GAAOJ,GAAQI,EAAMH,EAAWG,EAAMF,EAAK,GACzD/B,CACX,CAAC,EACE,CAGA,SAAW,CACd,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,qCAAqC,EAC3E,MAAMc,EAAI,KAAK,SAAUoB,EAAM,CAAC,EAAGC,EAAK,CAAC,EAAGC,EAAO,KAAK,MAAQ,EAChE,UAAWC,KAAM,KAAK,MAAM,WAAW,EAAG,CACtC,MAAMC,EAAKvC,EAAQsC,CAAE,EAAKD,EAAOC,EAAMA,EACvCF,EAAGG,CAAE,EAAIxB,EAAEuB,CAAE,EACbH,EAAI,KAAKI,CAAE,CACf,CACA,YAAK,SAAWH,EAChB,KAAK,MAAQD,EACb,KAAK,MAAM,QAAQ,EACZ,IACJ,CAGA,IAAI,KAAO,CAAE,OAAO,KAAK,IAAM,CAE/B,IAAI,IAAKK,EAAG,CACVA,EACKA,GAAG,OAASA,EAAE,SAAWA,EAAE,QAAUA,EAAE,SAAS,KAAK,KAAOA,GAD9D,OAAO,KAAK,IAEjB,CAOA,IAAKvC,EAAKuB,EAAOP,EAAS,GAAO,CACpC,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,iCAAiC,EAGvE,GAFIhB,IAAQ,SAAWA,EAAM,KAAK,OAClCA,EAAM,KAAKK,GAASL,CAAG,EACnBA,IAAQ,OAAW,OACvB,MAAMO,EAAO,GAAKP,EACZiC,EAAMlC,EAAQQ,CAAI,GAAK,SAASA,EAAM,EAAE,EAC9C,IAAIiC,EAAU,GACd,GAAI,CAAC,OAAO,OAAO,KAAK,SAAUjC,CAAI,EAAG,CAErC,GADAiC,EAAU,GACNxB,EACP,GAAIiB,IAAQ,IAAS,CAAC,KAAK,MAAO,KAAK,MAAM,QAAQ1B,CAAI,MACpD,CACD,IAAIkC,EAAK,KAAK,MAAM,OACpB,KAAOA,EAAK,IAAM,CAAC1C,EAAQ,KAAK,MAAM0C,EAAK,CAAC,CAAC,GAAKR,EAAM,KAAK,MAAMQ,EAAK,CAAC,IAAI,EAAEA,EAC/E,KAAK,MAAM,OAAOA,EAAI,EAAGlC,CAAI,CACjC,SAEI0B,IAAQ,IAASA,GAAO,KAAK,MAAO,KAAK,MAAM,KAAK1B,CAAI,MACvD,CACD,IAAIkC,EAAK,EACT,KAAOA,EAAK,KAAK,MAAM,SAAW,CAAC1C,EAAQ,KAAK,MAAM0C,CAAE,CAAC,GAAKR,EAAM,KAAK,MAAMQ,CAAE,IAAI,EAAEA,EACvF,KAAK,MAAM,OAAOA,EAAI,EAAGlC,CAAI,CACjC,CAEO0B,IAAQ,IAASA,GAAO,KAAK,QAAO,KAAK,MAAQA,EAAM,EAC/D,CACA,GAAI,OAAOV,GAAU,UAAY,KAAK,cAAgBA,IAAU,KAC5D,OAAQA,GAAO,aAAa,KAAM,CAClC,KAAK,OACL,IAAK,QACL,IAAK,SACR,KAAK,SAAShB,CAAI,EAAI,KAAK,QAAQgB,CAAK,EACxC,MACG,QACH,KAAK,SAAShB,CAAI,EAAIgB,EACtB,KACG,MACG,KAAK,SAAShB,CAAI,EAAIgB,EAC7B,OAAI,KAAK,UAAU,KAAK,KAAKhB,CAAI,EAC7BiC,GAAS,KAAK,MAAM,QAAQ,EACzBjB,CACJ,CAEA,eAAgBjB,EAAG,CACtB,YAAK,aAAeA,EACb,IACJ,CAEA,OAAQiC,EAAG,CACd,YAAK,IAAMA,EACJ,IACJ,CAGA,OAAS,CACZ,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,mCAAmC,EACzE,GAAI,KAAK,SAAU,MAAM,IAAI,UAAU,sCAAsC,EAC7E,OAAK,KAAK,OACI,KAAK,MAAM,QAAUtB,GAAMA,EAAG,IAC/B,IAAM,CACf,MAAMyB,EAAM,KAAK,OAAO,CAAC,EACzB,YAAKd,GAAU,EAAG,KAAK,MAAO,EAAE,EACzBc,CACX,CAAC,EANgB,MAOd,CAGA,IAAI,MAAQ,CACf,YAAK,MAAM,OAAO,EACX,KAAK,MAAM,MACf,CAGA,WAAYvC,EAAO,CACtB,MAAMuB,EAAK,IAAIxB,EACf,OAAI,KAAK,eAAcwB,EAAG,YAAc,IACxCA,EAAG,IAAM,KAAK,MAAM,OAAO,EACvBvB,EAAM,QAAQuB,EAAG,KAAK,GAAGvB,CAAK,EAC3BuB,CACJ,CAEA,IAAI,SAAW,CAClB,YAAK,MAAM,OAAO,EACX,KAAK,QACT,CAEA,YAAc,CACjB,YAAK,MAAM,OAAO,EACX,KAAK,QAAQ,EAAE,UAAU,KAAK,OAAO,CAAC,EAAE,QAAQ,CACpD,CAGA,QAAU,CACb,YAAK,MAAM,OAAO,EACX,CAAC,KAAK,UAAW,KAAM,KAAK,MAAO,MAAO,KAAK,MAAM,EAAI,CAAC,CAC9D,CAGA,OAAQ,CAAE,QAAAhB,EAAU,GAAO,OAAAiC,EAAS,EAAM,EAAI,CAAC,EAAG,CACrD,KAAK,MAAM,OAAO,EAClB,MAAMC,EAASC,GAAOhD,EAAegD,CAAG,EAAE,QAAQ,OAAQ,MAAM,EAChE,SAASC,EAAU3C,EAAO,CACtB,MAAM4C,EAAQ,CAAC,EACf,UAAWC,KAAQ7C,EAAO,CAC7B,MAAM8C,EAAOF,EAAM,OAASA,EAAM,MAAM,EAAE,EAAE,MAAM,EAAE,EAAI,GAClDG,EAAQD,GAAQD,EAAK,CAAC,GAAK,IAC7BC,GAAQ,CAAC,WAAW,KAAKC,CAAK,GAAGH,EAAM,KAAK,GAAG,EACnDA,EAAM,KAAKC,CAAI,CACZ,CACA,OAAOD,EAAM,KAAK,EAAE,CACxB,CACA,SAASI,EAAY5B,EAAO,CACxB,OAAQA,EAAO,CACf,IAAK,GAAO,MAAO,KACnB,KAAK,KAAM,MAAO,KAClB,IAAK,GAAM,MAAO,KAClB,KAAK,OAAW,MAAO,IACvB,CACA,OAAQ,OAAOA,EAAO,CACtB,IAAK,SAAU,OAAOA,EAAM,SAAS,EAAI,IACzC,IAAK,SAAU,OAAOA,EAAM,SAAS,EACrC,IAAK,SAER,MAAI,kDAAkD,KAAKA,CAAK,EAAUA,EACnE,IAAMqB,EAAOrB,CAAK,EAAI,GAC1B,CACA,OAAIA,aAAiBrB,EAAc,IAAMkD,EAAW7B,CAAK,EAAI,IACtD,UACX,CACA,SAAS6B,EAAYC,EAAM,CACvB,IAAIC,EAAS,EACb,GAAIX,GAAUU,EAAK,YAAc,GAAM,OAASV,IAAW,UAAa,UAAY,GACpF,MAAMxC,EAAQ,CAAC,EACf,UAAWoD,KAAMF,EAAK,QAAQ,EACjC,GAAItD,EAAQwD,EAAG,CAAC,CAAC,EAAG,CAChB,GAAIZ,GAAUU,EAAK,WAAW,CAAC,EAAG,CACjCV,IAAW,WAAWxC,EAAM,KAAK,OAAO,EAC5C,QACG,CACA,MAAM8B,EAAM,SAASsB,EAAG,CAAC,EAAG,EAAE,EAC9BpD,EAAM,MAAO8B,IAAQqB,EAAU,GAAK,GAAGrB,CAAG,KAAOkB,EAAWI,EAAG,CAAC,CAAC,CAAC,EAClED,EAASrB,EAAM,CACnB,MACQU,GAAUU,EAAK,WAAWE,EAAG,CAAC,CAAC,EAClCZ,IAAW,WAAWxC,EAAM,KAAK,SAAS,EACpCA,EAAM,KAAKgD,EAAWI,EAAG,CAAC,CAAC,EAAI,IAAMJ,EAAWI,EAAG,CAAC,CAAC,CAAC,EAG9D,OAAQ7C,EAAUoC,EAAS3C,CAAK,EAAIA,EAAM,KAAK,GAAG,CACtD,CACA,MAAO,KAAOiD,EAAW,IAAI,EAAE,QAAQ,QAAS,MAAM,EAAI,IACvD,CAEA,SAAUI,EAAU,CAAC,EAAG,CAC3B,OAAO,KAAK,OAAO,CAAE,OAAQ,GAAM,GAAGA,CAAQ,CAAC,CAC5C,CAMA,WAAYrD,EAAO,CACtB,GAAI,KAAK,QAAS,MAAM,IAAI,UAAU,qCAAqC,EAC3E,GAAI,KAAK,SAAU,MAAM,IAAI,UAAU,wCAAwC,EAE/E,OADc,KAAK,MAAM,QAAUc,GAAMA,EAAG,IACtC,IAAMd,EAAM,WAAW,EAAE,QAAQoB,GAAS,CAC5C,GAAIA,aAAiBrB,EACxB,KAAK0B,GAAU,EAAG,KAAK,MAAOL,EAAM,IAAI,EACxC,KAAK,YAAYA,EAAM,QAAQ,EAAG,EAAI,UACxB,OAAOA,GAAU,SAAU,CACzC,MAAMkC,EAAO,MAAM,QAAQlC,CAAK,EAAIA,EAAM,OAAS,OAAO,KAAKA,CAAK,EAAE,OAAOd,GAAKV,EAAQU,CAAC,CAAC,EAAE,OAAO,CAACiD,EAAKC,IAAQ,KAAK,IAAID,EAAKC,CAAG,EAAG,EAAE,EAAI,EAC7I,KAAK/B,GAAU,EAAG,KAAK,MAAO6B,CAAI,EAClC,KAAK,YAAY,OAAO,QAAQlC,CAAK,EAAG,EAAI,CACzC,MAAO,KAAK,QAAQ,CAACA,CAAK,CAAC,CAC/B,CAAC,CAAC,EACK,IACJ,CAGA,CAAC,QAAU,CACd,KAAK,MAAM,OAAO,EAClB,QAASD,EAAI,EAAGA,EAAI,KAAK,MAAO,EAAEA,EAAG,MAAM,KAAK,GAAGA,CAAC,CACjD,CAEAjB,GAAUL,EAAK,CAClB,GAAI,EAAAC,EAAWD,CAAG,IACdA,EAAM,SAASA,EAAK,EAAE,EAAI,KAAK,MAC3BA,EAAM,IAEd,OAAOA,CACJ,CACJ,CAGAE,EAAM,UAAU,IAAMA,EAAM,UAAU,GAStC,MAAM0D,EAAW,CACb,IAAK,cACL,IAAK,+EACL,IAAK,oBACL,IAAK,oBACL,KAAM,UACN,IAAK,OACL,IAAK,iBACT,EACMC,EAAS,IAAI,OAAO,IAAM,+BAA+B,MAAM,GAAG,EAAE,IAAIpD,GAAKmD,EAASnD,CAAC,CAAC,EAAE,KAAK,GAAG,EAAI,IAAK,GAAG,EAC9GqD,EAAU,IAAI,OAAO,IAAMF,EAAS,IAAM,GAAG,EAG5C,SAASG,EAAWlB,EAAKmB,EAAK,GAAO,CACxC,IAAIC,EAAQpB,EAAI,MAAM,gBAAgB,EACtC,GAAI,CAACoB,EAAO,MAAM,IAAI,YAAY,mCAAmC,EACrE,MAAMC,EAASD,EAAM,CAAC,EAAE,QAAQ,UAAW,IAAI,EAAE,MAAMJ,CAAM,EAAE,OAAOM,GAAK,CAAC,qBAAqB,KAAKA,CAAC,CAAC,EACxGF,EAAQ,OACR,MAAMG,EAAY,IAAM,CAC3B,MAAMC,EAAQH,EAAO,MAAM,EAC3B,OAAIJ,EAAQ,KAAKO,CAAK,EACd,MAAM,KAAKA,CAAK,EAAU,OAAOA,EAAM,MAAM,EAAG,EAAE,CAAC,EACnD,YAAY,KAAKA,CAAK,EAAU,SAASA,EAAM,QAAQ,MAAO,EAAE,EAAG,CAAC,EACpE,YAAY,KAAKA,CAAK,EAAU,SAASA,EAAM,QAAQ,MAAO,EAAE,EAAG,CAAC,EACpE,YAAY,KAAKA,CAAK,EAAU,SAASA,EAAM,QAAQ,MAAO,EAAE,EAAG,EAAE,EAClE,WAAWA,CAAK,EAEvBA,EAAM,CAAC,IAAM,KAAOA,EAAM,CAAC,IAAM,IAAYA,EAC1CvE,EAAiBuE,EAAM,MAAM,EAAG,EAAE,CAAC,CACvC,EACMC,EAAa,IAAM,CAC5B,GAAIJ,EAAO,CAAC,IAAM,IAAK,CACnB,GAAI,CAACF,EAAI,OAAQE,EAAO,CAAC,EAAG,CAC5B,IAAK,KAAM,OAAAA,EAAO,MAAM,EAAU,GAClC,IAAK,KAAM,OAAAA,EAAO,MAAM,EAAU,KAClC,IAAK,KAAM,OAAAA,EAAO,MAAM,EAAU,GAClC,IAAK,KAAMA,EAAO,MAAM,EAAG,MAC3B,CACA,OAAOE,EAAU,CACrB,CACA,OAAAF,EAAO,MAAM,EACNK,EAAW,CACf,EACA,SAASA,GAAc,CAC1B,MAAMC,EAAS,IAAItE,EACnB,KAAOgE,EAAO,QAAUA,EAAO,CAAC,IAAM,KAAK,CACvC,IAAIlE,EACJ,GAAIkE,EAAO,CAAC,IAAM,IACrBlE,EAAMoE,EAAU,EAChBF,EAAO,MAAM,UACC,CAACF,GAAME,EAAO,CAAC,IAAM,KAAM,CACzCA,EAAO,MAAM,EACb,EAAEM,EAAO,KACT,QACG,CACAA,EAAO,IAAIxE,EAAKsE,EAAW,CAAC,CAChC,CACA,OAAIJ,EAAO,CAAC,IAAM,KAAKA,EAAO,MAAM,EAC7BM,CACJ,CACA,MAAMA,EAASD,EAAW,EAE1B,GAAIL,EAAO,OAAQ,MAAM,IAAI,YAAY,gBAAgB,EACzD,OAAOM,CACX,CAGA,MAAMC,EAAQ,CAAE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,EAChD,SAASC,EAAY7B,EAAK,CAC7B,OAAOkB,EAAU,KAAOlB,EAAI,WAAW,0BAA2B,EAAE,EACjE,MAAM,qBAAqB,EAC3B,IAAI/B,GAAMA,EAAE,CAAC,IAAM,IAAOA,EAAIA,EAAE,QAAQ,UAAW6D,GAAKF,EAAME,CAAC,CAAC,CAAC,EACjE,KAAK,EAAE,EAAI,KAAM,EAAI,CAC5B",
  "names": ["escapeJSString", "unescapeJSString", "isIndex", "key", "isNegIndex", "NANOS", "items", "defVal", "#wrapKey", "v", "skey", "ret", "k", "compact", "ik", "f", "kv", "s", "entries", "insert", "cb", "e", "pairs", "batch", "end", "i", "value", "keys", "andNew", "nn", "base", "#renumber", "from", "to", "by", "move", "ind", "nks", "ns", "last", "ok", "nk", "r", "changed", "ki", "res", "redact", "escape", "str", "squished", "parts", "item", "tail", "joint", "valueToStr", "itemsToStr", "node", "expInd", "en", "options", "next", "acc", "cur", "slidPats", "slidRE", "slidNum", "parseSLID", "qj", "match", "tokens", "t", "parseLeft", "token", "parseRight", "parseItems", "result", "qjMap", "parseQJSON", "c"]
}
