{
  "version": 3,
  "sources": ["../src/nanos.esm.js"],
  "sourcesContent": ["/*\n * NANOS - Named and numbered ordered storage\n * Copyright 2024-2025 by Kappa Computer Solutions, LLC and Brian Katzung\n * Author: Brian Katzung <briank@kappacs.com>\n */\n\nimport { escapeJSString, unescapeJSString } from './vendor/escape-js.esm.js';\n\n//////////////////////////////////////////////////////////////////////\n// SLID and QJSON parsing details\n//////////////////////////////////////////////////////////////////////\n\n// SysCL List Data lexical token regexps\nconst slidPats = {\n\tmlc: '/\\\\*.*?\\\\*/',\t\t\t// Multi-line comment\n\t// Numbers\n\tflt: '[+-]?\\\\d+(?:[.]\\\\d+)?(?:[eE][+-]?\\\\d+)?(?![0-9a-zA-Z])',\n\tint: '[+-]?(?:0[bB][01]+|0[oO][0-7]+|0[xX][0-9a-fA-F]+|\\\\d+)n?(?![0-9a-zA-Z])',\n\tsqs: \"'(?:\\\\\\\\'|[^'])*'\",\t// Single-quoted string\n\tdqs: '\"(?:\\\\\\\\\"|[^\"])*\"',\t// Double-quoted string\n\tstok: '[[=\\\\]]',\t\t\t// Special tokens\n\tspc: '\\\\s+',\t\t\t\t// Space\n\toth: '(?:[^\\'\"/[=\\\\]\\\\s]|\\\\/(?![*]))+',\t\t// Other\n};\nconst slidRE = new RegExp('(' + 'mlc flt int sqs dqs stok spc oth'.split(' ').map((k) => slidPats[k]).join('|') + ')', 's');\nconst slidNum = new RegExp(`^(${slidPats.flt}|${slidPats.int})$`);\n\nconst qjMap = { '{': '[', '}': ']', ',': ' ', ':': '=' };\n\n//////////////////////////////////////////////////////////////////////\n\n/**\n * Checks if a key is a valid array index.\n * @param {string} key\n * @returns {boolean}\n */\nexport const isIndex = (key) => /^(?:0|[1-9]\\d*)$/.test(key);\n\n/**\n * Checks if a key is a negative index.\n * @param {string} key\n * @returns {boolean}\n */\nexport const isNegIndex = (key) => /^-[1-9]\\d*$/.test(key);\n\n/**\n * Checks if a value is a plain object.\n * @param {*} value\n * @returns {boolean}\n */\nconst isPlainObject = (value) => {\n\tif (typeof value !== 'object' || value === null) return false;\n\tconst consName = value?.constructor?.name;\n\treturn (consName === undefined || consName === 'Object');\n};\n\n/**\n * Named and Numbered Ordered Storage.\n * @class\n */\nexport class NANOS {\n\t/**\n\t * Creates a new NANOS instance.\n\t * @param {...*} items\n\t */\n\tconstructor (...items) {\n\t\tthis._options = {};\n\t\tthis.clear();\n\t\tthis.push(...items);\n\t}\n\n\t/**\n\t * Get value at key or index. If the value is reactive, the \"final\"\n\t * (non-reactive) value is returned. See also `atRaw()`.\n\t * @param {string|number|Array<(string|number)>} key Path to value\n\t * @param {object} [opts] Options object\n\t * @param {*} [opts.default] Default value to return if key is absent\n\t * @param {boolean} [opts.raw=false] Return the raw value instead\n\t * @returns {*}\n\t */\n\tat (key, opts = {}) {\n\t\topts = this.#getOpts(opts, 'default');\n\t\tif (Array.isArray(key)) {\n\t\t\t// deno-lint-ignore no-this-alias\n\t\t\tlet next = this;\n\t\t\tfor (const curKey of key) {\n\t\t\t\tnext = this.#final(next);\n\t\t\t\tif (!(next instanceof NANOS) || !next.has(curKey)) return opts.default;\n\t\t\t\tnext = next.atRaw(curKey);\n\t\t\t}\n\t\t\tif (!opts.raw && this._rio?.get) next = this.#final(next);\n\t\t\treturn next;\n\t\t}\n\t\tthis._rio?.depend();\n\t\tkey = this.#wrapKey(key);\n\t\tif (Object.hasOwn(this._storage, key)) {\n\t\t\tlet ret = this._storage[key];\n\t\t\tif (!opts.raw && this._rio?.get) ret = this.#final(ret);\n\t\t\treturn ret;\n\t\t}\n\t\treturn opts.default;\n\t}\n\n\t/**\n\t * Get the \"raw\" value at a key or index (negative index relative to end).\n\t * This may be a reactive value. See also `at()`.\n\t * @param {string|number|Array<(string|number)>} key\n\t * @param {object} [opts] Options object\n\t * @param {*} [opts.default] Default value to return if key is absent\n\t * @returns\n\t */\n\tatRaw (key, opts = {}) {\n\t\topts = this.#getOpts(opts, 'default', { raw: true });\n\t\treturn this.at(key, opts);\n\t}\n\n\t/**\n\t * Clears the NANOS instance.\n\t * @returns {this}\n\t */\n\tclear () {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"clear\" after locking');\n\t\tthis._next = 0;\n\t\tthis._keys = [];\n\t\tthis._storage = {};\n\t\tthis._lockInd = undefined;\n\t\tdelete this._redacted;\n\t\tthis._rio?.changed();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Freezes this NANOS and all nested NANOS values recursively.\n\t * @returns {this}\n\t */\n\tdeepFreeze () {\n\t\tthis.freeze();\n\t\tfor (const [_key, value] of this.entries()) {\n\t\t\tif (value instanceof NANOS) {\n\t\t\t\tvalue.deepFreeze();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Deletes a key-value pair.\n\t * NOTE: unlike the delete statement, this returns the deleted value!\n\t * @param {string|number} key\n\t * @param {object} [opts] Options object\n\t * @param {boolean} [opts.raw=false] Return the raw, rather than final, deleted value\n\t * @returns {*}\n\t */\n\tdelete (key, opts = {}) {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"delete\" after locking');\n\t\tconst skey = String(key);\n\t\tconst ret = this._storage[skey];\n\t\tif (Object.hasOwn(this._storage, skey)) {\n\t\t\tdelete this._storage[skey];\n\t\t\tthis._keys = this._keys.filter((k) => k !== skey);\n\t\t\tthis._rio?.changed();\n\t\t}\n\t\treturn (opts.raw ? ret : this.#final(ret));\n\t}\n\n\t/** Signals a dependency for reactive interfaces. */\n\tdepend () { this._rio?.depend(); }\n\n\t/**\n\t * Returns an iterator of [key, value] pairs.\n\t * Compact mode uses numeric index keys instead of the standard strings\n\t * (e.g. 0 instead of '0').\n\t * @param {object} [opts] Options object\n\t * @param {boolean} [opts.compact=false] Return numeric index keys instead of strings\n\t * @param {boolean} [opts.raw=false] Return raw, rather than final, reactive values\n\t * @yields {[string|number, *]}\n\t */\n\t*entries (opts = {}) {\n\t\topts = this.#getOpts(opts, 'compact');\n\t\tthis._rio?.depend();\n\t\tconst storage = this._storage;\n\t\tconst ik = opts.compact ? ((k) => isIndex(k) ? parseInt(k, 10) : k) : ((k) => k);\n\t\tconst fv = (opts.raw || !this._rio?.get) ? ((v) => v) : ((v) => this.#final(v));\n\t\tfor (const k of this._keys) yield [ ik(k), fv(storage[k]) ];\n\t}\n\n\t/**\n\t * Returns a shallow copy of elements for which f(value, key) is true.\n\t * @param {function(*, string|number, NANOS): boolean} f The filter function\n\t * @param {object} [opts] Options object, passed to entries()\n\t * @returns {NANOS}\n\t */\n\tfilter (f, opts = {}) {\n\t\tthis._rio?.depend();\n\t\tconst result = this.similar();\n\t\tresult.fromEntries([...this.entries(opts)].filter((kv) => f(kv[1], kv[0], this)));\n\t\treturn result;\n\t}\n\n\t#final (value) {\n\t\twhile (this._rio?.isReactive?.(value)) value = this._rio.get(value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Returns first [key, value] where f(value, key) is true; cf find, findIndex.\n\t * @param {function(*, string|number, NANOS): boolean} f\n\t * @param {object} [opts] Options object\n\t * @param {boolean} [opts.raw=false] Pass the filter raw, rather than final, reactive values\n\t * @returns {[string|number, *]|undefined}\n\t */\n\tfind (f, opts = {}) {\n\t\tthis._rio?.depend();\n\t\tconst s = this._storage;\n\t\tconst toFinal = (opts.raw || !this._rio?.get) ? ((v) => v) : ((v) => this.#final(v));\n\t\tfor (const k of this._keys) {\n\t\t\tconst final = toFinal(s[k]);\n\t\t\tif (f(final, k, this)) return [k, final];\n\t\t}\n\t}\n\n\t/**\n\t * Returns last [key, value] where f(value, key) is true; cf findLast, findLastIndex.\n\t * @param {function(*, string|number, NANOS): boolean} f\n\t * @param {object} [opts] Options object\n\t * @param {boolean} [opts.raw=false] Pass the filter raw, rather than final, reactive values\n\t * @returns {[string|number, *]|undefined}\n\t */\n\tfindLast (f, opts = {}) {\n\t\tthis._rio?.depend();\n\t\tconst s = this._storage;\n\t\tconst toFinal = (opts.raw || !this._rio?.get) ? ((v) => v) : ((v) => this.#final(v));\n\t\tfor (const k of this._keys.toReversed()) {\n\t\t\tconst final = toFinal(s[k]);\n\t\t\tif (f(final, k, this)) return [k, final];\n\t\t}\n\t}\n\n\t/**\n\t * Executes a function for each element.\n\t * @param {function(*, string|number, NANOS): void} f\n\t * @param {object} [opts] Options object\n\t * @param {boolean} [opts.raw=false] Pass the filter raw, rather than final, reactive values\n\t */\n\tforEach (f, opts = {}) {\n\t\tthis._rio?.depend();\n\t\tconst storage = this._storage;\n\t\tconst toFinal = (opts.raw || !this._rio?.get) ? ((v) => v) : ((v) => this.#final(v));\n\t\tfor (const k of this._keys) {\n\t\t\tconst final = toFinal(storage[k]);\n\t\t\tf(final, k, this);\n\t\t}\n\t}\n\n\t/**\n\t * Renders the NANOS completely locked and immutable.\n\t * @returns {this}\n\t */\n\tfreeze () {\n\t\tif (!Object.isFrozen(this)) {\n\t\t\tthis._locked = true;\n\t\t\tthis._lockInd = true;\n\t\t\tObject.freeze(this);\n\t\t}\n\t\tObject.freeze(this._keys);\n\t\tObject.freeze(this._storage);\n\t\tif (typeof this._redacted === 'object') Object.freeze(this._redacted);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Populates the NANOS from another NANOS\n\t * @param {object} [opts] Options object\n\t * @param {boolean} [opts.deep] Deep-copy instead of shallow\n\t * @param {boolean} [opts.raw] Transfer raw values\n\t */\n\tfrom (source, opts = {}) {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"from\" after locking');\n\t\tif (!(source instanceof NANOS)) return this;\n\t\tconst batch = this._rio?.batch || ((cb) => cb());\n\t\tbatch(() => {\n\t\t\tfor (const kv of source.entries({ raw: opts.raw })) {\n\t\t\t\tlet [key, value] = kv;\n\t\t\t\tif (opts.deep && value instanceof NANOS) {\n\t\t\t\t\tvalue = this.similar().from(value, opts);\n\t\t\t\t}\n\t\t\t\tthis.set(key, value, { raw: true });\n\t\t\t}\n\t\t\tthis.next = source.next;\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Populates the NANOS from an array of [key, value] entries.\n\t * @param {Array<[string|number, *]>} entries\n\t * @param {boolean} [insert=false] Use insert mode instead of append mode\n\t * @returns {this}\n\t */\n\tfromEntries (entries, insert = false) {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"fromEntries\" after locking');\n\t\tif (insert && this._lockInd) throw new TypeError('NANOS: Cannot insert \"fromEntries\" after index lock');\n\t\tconst batch = this._rio?.batch || ((cb) => cb());\n\t\tbatch(() => {\n\t\t\tif (insert) for (const e of [...entries].reverse()) this.set(e[0], e[1], true);\n\t\t\telse for (const e of entries) this.set(e[0], e[1]);\n\t\t\tthis._rio?.changed();\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Populates from a list of key-value pairs.\n\t * Can be [ key1, value1, ... keyN, valueN ]\n\t * or { type: '@NANOS@', next, pairs }\n\t * @param {...*} pairs\n\t * @returns {this}\n\t */\n\tfromPairs (...pairs) {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"fromPairs\" after locking');\n\t\tconst batch = this._rio?.batch || ((cb) => cb());\n\t\tif (isPlainObject(pairs[0]) && pairs[0].type === '@NANOS@') {\n\t\t\tbatch(() => {\n\t\t\t\tthis.fromPairs(pairs[0].pairs);\n\t\t\t\tthis.next = pairs[0].next;\n\t\t\t\tthis._rio?.changed();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\tif (Array.isArray(pairs[0])) pairs = pairs[0];\n\t\tconst end = pairs.length - 1;\n\t\tbatch(() => {\n\t\t\tfor (let i = 0; i < end; i += 2) {\n\t\t\t\tif (pairs[i] === undefined && !(i + 1 in pairs)) ++this._next;\n\t\t\t\telse this.set(pairs[i], pairs[i + 1]);\n\t\t\t}\n\t\t\tthis._rio?.changed();\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return a normalized options object when the value might historically have been a single scalar option.\n\t * @param {object|boolean} optParam \n\t * @param {string} defKey \n\t * @param {object} defOpts \n\t * @returns \n\t */\n\t#getOpts (optParam, defKey, defOpts = {}) {\n\t\tconst optObj = isPlainObject(optParam) ? optParam : { [defKey]: optParam };\n\t\treturn { ...defOpts, ...optObj };\n\t}\n\n\t/**\n\t * Checks for the existence of a key.\n\t * Instead of \"key in NANOS\".\n\t * @param {string|number} key\n\t * @returns {boolean}\n\t */\n\thas (key) {\n\t\tthis._rio?.depend();\n\t\treturn Object.hasOwn(this._storage, this.#wrapKey(key));\n\t}\n\n\t/**\n\t * Checks if a value exists.\n\t * @param {*} value\n\t * @param {object} [opts] Options object, passed to keyOf/find\n\t * @returns {boolean}\n\t */\n\tincludes (value, opts = {}) {\n\t\treturn this.keyOf(value, opts) !== undefined;\n\t}\n\n\t/**\n\t * Iterates over indexed entries.\n\t * @param {object} [opts] Options object, passed to entries\n\t * @param {boolean} [opts.compact=false] Return number indexes rather than strings\n\t * @param {boolean} [opts.raw=false] Return raw, rather than final, reactive values\n\t * @yields {[string|number, *]}\n\t */\n\t*indexEntries (opts) {\n\t\topts = this.#getOpts(opts, 'compact');\n\t\tfor (const kv of this.entries(opts)) if (isIndex(kv[0])) yield kv;\n\t}\n\n\t/**\n\t * Iterates over index keys.\n\t * @yields {string}\n\t */\n\t*indexKeys () {\n\t\tthis._rio?.depend();\n\t\tfor (const k of this._keys) if (isIndex(k)) yield k;\n\t}\n\n\t/**\n\t * Is a key/value (or, if undef, the key-set) locked?\n\t * @param {string|number} [key]\n\t * @returns {boolean}\n\t */\n\tisLocked (key) {\n\t\tthis._rio?.depend();\n\t\tif (key === undefined) return !!this._locked;\t// Key-set locked\n\t\tkey = this.#wrapKey(key);\n\t\tif (this._locked && !Object.hasOwn(this._storage, key)) return true;\n\t\treturn !Object.getOwnPropertyDescriptor(this._storage, key)?.writable;\n\t}\n\n\t/**\n\t * Is a key/value redacted?\n\t * @param {string|number} key\n\t * @returns {boolean}\n\t */\n\tisRedacted (key) {\n\t\tthis._rio?.depend();\n\t\tif (this._redacted === true) return true;\n\t\tkey = this.#wrapKey(key);\n\t\tif (isIndex(key)) return !!this._redacted?.[0];\n\t\treturn !!this._redacted?.[key];\n\t}\n\n\t/**\n\t * Returns first key/index with matching value, or undefined; cf indexOf.\n\t * @param {*} value\n\t * @param {object} [opts] Options object, passed to find\n\t * @returns {string|number|undefined}\n\t */\n\tkeyOf (value, opts = {}) { return this.find((v) => v === value, opts)?.[0]; }\n\n\t/**\n\t * Returns an iterator for the keys.\n\t * @returns {Iterator<string>}\n\t */\n\tkeys () {\n\t\tthis._rio?.depend();\n\t\treturn this._keys.values();\n\t}\n\n\t/**\n\t * Returns last key/index with matching value, or undefined; cf lastIndexOf.\n\t * @param {*} value\n\t * @param {object} [opts] Options object, passed to findLast\n\t * @returns {string|number|undefined}\n\t */\n\tlastKeyOf (value, opts = {}) {\n\t\treturn this.findLast((v) => v === value, opts)?.[0];\n\t}\n\n\t/**\n\t * Lock specific *values* by key (doesn't affect key addition/removal).\n\t * @param {...(string|number)} keys\n\t * @returns {this}\n\t */\n\tlock (...keys) {\n\t\tif (keys.length === 1 && Array.isArray(keys[0])) keys = keys[0];\n\t\tfor (let key of keys) {\n\t\t\tkey = this.#wrapKey(key);\n\t\t\tif (isIndex(key)) this._lockInd = true;\n\t\t\tif (key !== undefined) Object.defineProperty(this._storage, key, {\n\t\t\t\tvalue: this.at(key), enumerable: true,\n\t\t\t\twritable: false, configurable: false\n\t\t\t});\n\t\t}\n\t\tthis._rio?.changed();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lock all current (and possibly new) *values* (doesn't affect keys).\n\t * @param {boolean} [andNew=false] Also lock new keys' values as they are added\n\t * @returns {this}\n\t */\n\tlockAll (andNew = false) {\n\t\tif (andNew) this._lockNew = true;\n\t\tthis.lock(this._keys);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lock the *key* set (no new keys or indexes, but unlocked values can still change).\n\t * @returns {this}\n\t */\n\tlockKeys () {\n\t\tthis._locked = true;\n\t\tthis._rio?.changed();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Determine if a value is map-like (key: value, ...).\n\t * @param {*} value\n\t * @returns {boolean}\n\t */\n\t#mapish (value) {\n\t\treturn (isPlainObject(value) || (!this._options.opaqueMaps && value instanceof Map));\n\t}\n\n\t/**\n\t * Iterates over named entries.\n\t * @param {object} [opts] Options block, passed to entries\n\t * @yields {[string, *]}\n\t */\n\t*namedEntries (opts = {}) {\n\t\tfor (const kv of this.entries(opts)) if (!isIndex(kv[0])) yield kv;\n\t}\n\n\t/**\n\t * Iterates over named keys.\n\t * @param {object} [opts] Options block, passed to entries\n\t * @yields {string}\n\t */\n\t*namedKeys (opts = {}) {\n\t\tfor (const kv of this.entries({ ...opts, raw: true })) if (!isIndex(kv[0])) yield kv[0];\n\t}\n\n\t/**\n\t * \"Next\" index (max index + 1); similar to array.length.\n\t * @returns {number}\n\t */\n\tget next () {\n\t\tthis._rio?.depend();\n\t\treturn this._next;\n\t}\n\t/**\n\t * Sets the next index, truncating if necessary.\n\t * @param {number} nn\n\t */\n\tset next (nn) {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot set \"next\" after locking');\n\t\tif (!Number.isInteger(nn) || nn < 0) return;\n\t\tfor (let i = this._next; --i >= nn; this.delete(i));\n\t\tif (this._next !== nn) {\n\t\t\tthis._next = nn;\n\t\t\tthis._rio?.changed();\n\t\t}\n\t}\n\n\t/**\n\t * Return the current options.\n\t * @returns {object}\n\t */\n\tget options () {\n\t\treturn Object.assign({}, this._options);\n\t}\n\n\t/**\n\t * Returns a flat array of key-value pairs.\n\t * @param {boolean} [compact=false]\n\t * @returns {Array<*>}\n\t */\n\tpairs (opts = {}) {\n\t\topts = this.#getOpts(opts, 'compact');\n\t\treturn [...this.entries(opts)].flat(1);\n\t}\n\n\t/**\n\t * Parse relaxed, \"quasi-JSON\" (by way of SLID).\n\t * The distinction between { } and [ ] is ignored.\n\t * Values may be separated by commas or spaces.\n\t * Text without special characters need not be quoted.\n\t * Key-value pairs may be separated by `:` or `=`.\n\t * @param {string} str\n\t * @returns {NANOS}\n\t */\n\tstatic parseQJSON (str) {\n\t\treturn parseSLID('[(' + str.replaceAll(/^\\s*[\\[\\{]?|[\\]\\}]\\s*$/g, '')\n\t\t.split(/(\"(?:\\\\\\\\\"|[^\"])*\")/)\n\t\t.map((s) => (s[0] === '\"') ? s : s.replace(/[{},:]/g, (c) => qjMap[c]))\n\t\t.join('') + ')]', true);\n\t}\n\n\t/**\n\t * Parse SLID-format data, returning (potentially nested) NANOS.\n\t * @param {string} str\n\t * @param {boolean} [qj=false]\n\t * @returns {NANOS}\n\t */\n\tstatic parseSLID (str, qj = false) {\n\t\tlet match = str.match(/\\[\\((.*?)\\)\\]/s);\n\t\tif (!match) throw new SyntaxError('Missing SLID boundary marker(s)');\n\t\tconst tokens = match[1].replace(/\\)\\\\\\]/g, ')]').split(slidRE).filter((t) => !/^(\\s*|\\/\\*.*\\*\\/)$/.test(t));\n\t\tmatch = undefined;\n\t\tconst parseLeft = () => {\t\t// Can be left of = (numbers, strings)\n\t\t\tconst token = tokens.shift();\n\t\t\tif (slidNum.test(token)) {\n\t\t\t\tif (/n$/i.test(token)) return BigInt(token.slice(0, -1));\n\t\t\t\tif (/^[+-]?0b/i.test(token)) return parseInt(token.replace(/0b/i, ''), 2);\n\t\t\t\tif (/^[+-]?0o/i.test(token)) return parseInt(token.replace(/0o/i, ''), 8);\n\t\t\t\tif (/^[+-]?0x/i.test(token)) return parseInt(token.replace(/0x/i, ''), 16);\n\t\t\t\treturn parseFloat(token);\n\t\t\t}\n\t\t\tif (token === \"'\" || token === '\"') throw new SyntaxError(`Unmatched ${token} in SLID`);\n\t\t\tif (token[0] !== \"'\" && token[0] !== '\"') return token;\n\t\t\treturn unescapeJSString(token.slice(1, -1));\n\t\t}\n\t\tconst parseRight = () => {\t\t// More that can be right of =\n\t\t\tif (tokens[0] !== '[') {\n\t\t\t\tif (qj) switch (tokens[0]) {\n\t\t\t\tcase 'false': tokens.shift(); return false;\n\t\t\t\tcase 'null': tokens.shift(); return null;\n\t\t\t\tcase 'true': tokens.shift(); return true;\n\t\t\t\t} else switch (tokens[0]) {// Special values\n\t\t\t\tcase '@f': tokens.shift(); return false;\n\t\t\t\tcase '@n': tokens.shift(); return null;\n\t\t\t\tcase '@t': tokens.shift(); return true;\n\t\t\t\tcase '@u': tokens.shift(); return undefined;\n\t\t\t\t}\n\t\t\t\treturn parseLeft();\t\t// Everything OK on the left\n\t\t\t}\n\t\t\ttokens.shift();\n\t\t\treturn parseItems.call(this);\t\t// Nested lists\n\t\t}\n\t\tconst parseItems = () => {\n\t\t\tconst result = new NANOS();\n\t\t\twhile (tokens.length && tokens[0] !== ']') {\n\t\t\t\tlet key;\t\t\t\t\t\t// Default: positional\n\t\t\t\tif (tokens[1] === '=') {\t\t// Named value\n\t\t\t\t\tkey = parseLeft();\n\t\t\t\t\ttokens.shift();\n\t\t\t\t} else if (!qj && tokens[0] === '@e') { // Empty\n\t\t\t\t\ttokens.shift();\n\t\t\t\t\t++result.next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresult.set(key, parseRight());\n\t\t\t}\n\t\t\tif (tokens[0] === ']') tokens.shift();\n\t\t\treturn result;\n\t\t}\n\t\tconst result = parseItems();\n\t\t// SLID was malformed if any tokens are left\n\t\tif (tokens.length) throw new SyntaxError('Malformed SLID');\n\t\treturn result;\n\t}\n\n\t/**\n\t * Like Array.pop (only applies to indexed values).\n\t * @param {object} [opts] Options block, passed to delete\n\t * @param {boolean} [opts.raw=false] Return the raw, rather than final, popped value\n\t * @returns {*}\n\t */\n\tpop (opts = {}) {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"pop\" after locking');\n\t\tif (this._lockInd) throw new TypeError('NANOS: Cannot \"pop\" after index lock');\n\t\tif (!this._next) return undefined;\n\t\treturn this.delete(--this._next, opts);\n\t}\n\n\t/**\n\t * Appends new elements.\n\t * When pushing transparent objects (array, NANOS, object), named keys\n\t * are set directly and index keys are appended as an offset from _next\n\t * (therefore preserving any gaps).\n\t * Push [ object ] to add the actual object itself.\n\t * @param {...*} values\n\t * @returns {this}\n\t */\n\tpush (...values) {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"push\" after locking');\n\t\tconst batch = this._rio?.batch || ((cb) => cb());\n\t\tconst options = this._options, transform = options.transform;\n\t\tconst pushEntries = (entries, next = 0) => {\n\t\t\tconst base = this._next, minNext = base + next;\n\t\t\tfor (let [key, value] of entries) {\n\t\t\t\tif (isIndex(key)) {\n\t\t\t\t\t// Positional: preserve sparseness, potentially transforming\n\t\t\t\t\t// map-ish and set-ish values into nested NANOS\n\t\t\t\t\tconst newKey = base + parseInt(key, 10);\n\t\t\t\t\tif (transform && (this.#mapish(value) || this.#setish(value))) value = this.similar(value);\n\t\t\t\t\tthis.set(newKey, value);\n\t\t\t\t} else this.set(key, value);\n\t\t\t}\n\t\t\tif (this._next < minNext) this._next = minNext;\n\t\t};\n\t\tconst mergeMaps = (entries) => {\n\t\t\tfor (let [key, value] of entries) {\n\t\t\t\tif (isIndex(key)) {\n\t\t\t\t\t// Positional maps get merged; positional sets become nested NANOS\n\t\t\t\t\tif (this.#mapish(value)) mergeMaps((this.similar(value)).entries());\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (this.#setish(value)) value = this.similar(value);\n\t\t\t\t\t\tthis.set(undefined, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Named values just get set (promoting transparent containers)\n\t\t\t\t\tthis.set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst pushInner = (transform === 'sets') ? mergeMaps : pushEntries;\n\t\tconst pushOuter = (outer) => {\n\t\t\tif (isPlainObject(outer)) pushInner(Object.entries(outer));\n\t\t\telse if (Array.isArray(outer)) pushInner(Object.entries(outer), outer.length);\n\t\t\telse if (outer instanceof NANOS) pushInner(outer.entries(), outer.next);\n\t\t\telse if (!options.opaqueMaps && outer instanceof Map) pushInner(outer.entries());\n\t\t\telse if (!options.opaqueSets && outer instanceof Set) pushInner([...outer.values()].entries());\n\t\t\telse this.set(undefined, outer);\n\t\t};\n\t\tbatch(() => values.forEach(pushOuter));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Redacts values from string output.\n\t * NOTE: Only affects value returned by toString().\n\t * @param {...(string|number|boolean)} keys\n\t * @returns {this}\n\t */\n\tredact (...keys) {\n\t\tfor (const key of keys) {\n\t\t\tif (key === true) this._redacted = true;\n\t\t\tif (this._redacted === true) return;\n\t\t\tthis._redacted ||= {};\n\t\t\tif (isIndex(key)) this._redacted[0] = true;\n\t\t\telse this._redacted[key] = true;\n\t\t}\n\t\tthis._rio?.changed();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method to renumber indices.\n\t * @param {number} from\n\t * @param {number} to\n\t * @param {number} by\n\t */\n\t#renumber (from, to, by) {\n\t\tconst move = (k, by) => {\n\t\t\tif (Object.hasOwn(this._storage, k)) {\n\t\t\t\tthis._storage[k + by] = this._storage[k];\n\t\t\t\tdelete this._storage[k];\n\t\t\t}\n\t\t};\n\n\t\tif (by > 0) {\n\t\t\tif (to + by > this._next) this._next = to + by;\n\t\t\tfor (let k = to; --k >= from; ) move(k, by);\n\t\t} else if (by < 0) {\n\t\t\tif (to >= this._next) this._next += by;\n\t\t\tfor (let k = from; k < to; ++k) move(k, by);\n\t\t}\n\t\tif (by) this._keys = this._keys.map((key) => {\n\t\t\tconst ind = isIndex(key) && parseInt(key, 10);\n\t\t\tif (ind !== false && ind >= from && ind < to) return ind + by + '';\n\t\t\treturn key;\n\t\t});\n\t}\n\n\t/**\n\t * Reverse *in place*.\n\t * @returns {this}\n\t */\n\treverse () {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"reverse\" after locking');\n\t\tconst s = this._storage, nks = [], ns = {}, last = this._next - 1;\n\t\tfor (const ok of this._keys.toReversed()) {\n\t\t\tconst nk = isIndex(ok) ? String(last - parseInt(ok, 10)) : ok;\n\t\t\tns[nk] = s[ok];\n\t\t\tnks.push(nk);\n\t\t}\n\t\tthis._storage = ns;\n\t\tthis._keys = nks;\n\t\tthis._rio?.changed();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an iterator of [key, value] pairs in reverse (last-to-first key order).\n\t * Compact mode uses numeric index keys instead of the standard strings\n\t * (e.g. 0 instead of '0').\n\t * @param {boolean} [compact=false]\n\t * @yields {[string|number, *]}\n\t */\n\t*reverseEntries (opts = {}) {\n\t\topts = this.#getOpts(opts, 'compact');\n\t\tthis._rio?.depend();\n\t\tconst storage = this._storage;\n\t\tconst ik = opts.compact ? ((k) => isIndex(k) ? parseInt(k, 10) : k) : ((k) => k);\n\t\tconst toFinal = (opts.raw || !this._rio?.get) ? ((v) => v) : ((v) => this.#final(v));\n\t\tfor (const k of this._keys.toReversed()) yield [ ik(k), toFinal(storage[k]) ];\n\t}\n\n\t/**\n\t * Get/set reactive-interface object.\n\t * @returns {object|undefined}\n\t */\n\tget rio () { return this._rio; }\n\n\t/**\n\t * @param {object|undefined} r\n\t */\n\tset rio (r) {\n\t\tif (!r) delete this._rio;\n\t\telse if ((r?.batch && r.changed && r.create && r.depend)) this._rio = r;\n\t}\n\n\t/**\n\t * Sets a key-value pair.\n\t * If the key is undefined, the next sequential index is used.\n\t * New keys are added in the first (insert true) or last (insert false)\n\t * possible position that maintain increasing-index ordering constraints.\n\t * @param {string|number} [key]\n\t * @param {*} value\n\t * @param {object} [opts] Options object\n\t * @param {boolean} [opts.insert=false] Add to beginning instead of end\n\t * @param {boolean} [opts.raw=false] Do not auto-wrap value in a reactive\n\t * @returns {*}\n\t */\n\tset (key, value, opts = {}) {\n\t\topts = this.#getOpts(opts, 'insert');\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"set\" after locking');\n\t\tif (key === undefined) key = this._next;\n\t\tkey = this.#wrapKey(key);\n\t\tif (key === undefined) return;\n\t\tconst skey = String(key);\n\t\tconst ind = isIndex(skey) && parseInt(skey, 10);\n\t\tlet changed = false;\n\n\t\tif (!Object.hasOwn(this._storage, skey)) {\n\t\t\t// The key or index is new; add it in the proper place\n\t\t\tchanged = true;\n\t\t\tif (opts.insert) {\n\t\t\t\tif (ind === false || !this._next) this._keys.unshift(skey);\n\t\t\t\telse {\n\t\t\t\t\t// Earliest placement maintaining ascending index order\n\t\t\t\t\tlet ki = this._keys.length;\n\t\t\t\t\twhile (ki > 0 && (!isIndex(this._keys[ki - 1]) || ind < this._keys[ki - 1])) --ki;\n\t\t\t\t\tthis._keys.splice(ki, 0, skey);\n\t\t\t\t}\n\t\t\t} else { // append\n\t\t\t\tif (ind === false || ind >= this._next) this._keys.push(skey);\n\t\t\t\telse {\n\t\t\t\t\t// Latest placement maintaining ascending index order\n\t\t\t\t\tlet ki = 0;\n\t\t\t\t\twhile (ki < this._keys.length && (!isIndex(this._keys[ki]) || ind > this._keys[ki])) ++ki;\n\t\t\t\t\tthis._keys.splice(ki, 0, skey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ind !== false && ind >= this._next) this._next = ind + 1;\n\t\t}\n\n\t\tif (!opts.raw && this._rio?.onSet) value = this._rio.onSet(this, key, value);\n\n\t\tif (this._options.transform && (this.#setish(value) || this.#mapish(value))) {\n\t\t\t// Convert transparent containers to NANOS\n\t\t\tthis._storage[skey] = this.similar(value);\n\t\t} else {\n\t\t\tthis._storage[skey] = value;\n\t\t}\n\t\tif (this._lockNew) this.lock(skey);\n\t\tif (changed) this._rio?.changed();\n\t\treturn value;\n\t}\n\t/**\n\t * Set a raw value, bypassing any RIO `onSet` handler.\n\t * @param {string|number} [key]\n\t * @param {*} value\n\t * @param {object} [opts] Options object\n\t * @param {boolean} [opts.insert=false] Add to beginning instead of end\n\t * @returns\n\t */\n\tsetRaw (key, value, opts = {}) {\n\t\topts = this.#getOpts(opts, 'insert', { raw: true });\n\t\treturn this.set(key, value, opts);\n\t}\n\n\t/**\n\t * Determine if a value is set-like (value, ...).\n\t * @param {*} value\n\t * @returns {boolean}\n\t */\n\t#setish (value) {\n\t\treturn (Array.isArray(value) || (!this._options.opaqueSets && value instanceof Set));\n\t}\n\n\t/**\n\t * Set (merge) options\n\t * @param {object} options\n\t * @returns {this}\n\t *\n\t * opaqueMaps - Treat Map objects as opaque\n\t * opaqueSets - Treat Set objects as opaque\n\t * transform - Promote map-ish or set-ish values into nested NANOS objects,\n\t *\t   or merge them into the containing NANOS object, depending on the setting\n\t */\n\tsetOpts (options) {\n\t\tObject.assign(this._options, options);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Fluent interface for setting the RIO.\n\t * @param {object} r\n\t * @returns {this}\n\t */\n\tsetRIO (r) {\n\t\tthis.rio = r;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Like Array.shift (only applies to indexed values).\n\t * @param {object} [opts] Options block, passed to delete\n\t * @param {boolean} [opts.raw=false] Return the raw, rather than final, shifted value\n\t * @returns {*}\n\t */\n\tshift (opts = {}) {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"shift\" after locking');\n\t\tif (this._lockInd) throw new TypeError('NANOS: Cannot \"shift\" after index lock');\n\t\tif (!this._next) return undefined;\n\t\tconst batch = this._rio?.batch || ((cb) => cb());\n\t\treturn batch(() => {\n\t\t\tconst res = this.delete(0, opts);\n\t\t\tthis.#renumber(1, this._next, -1);\n\t\t\treturn res;\n\t\t});\n\t}\n\n\t/**\n\t * Size of list (# of keys / indexes).\n\t * @returns {number}\n\t */\n\tget size () {\n\t\tthis._rio?.depend();\n\t\treturn this._keys.length;\n\t}\n\n\t/**\n\t * Return a similarly-configured new NANOS.\n\t * @param {...*} items\n\t * @returns {NANOS}\n\t */\n\tsimilar (...items) {\n\t\tconst nn = new this.constructor();\n\t\tnn.setOptions(this._options);\n\t\tnn.rio = this._rio?.create();\n\t\tif (items.length) nn.push(...items);\n\t\treturn nn;\n\t}\n\n\t/**\n\t * Gets the underlying storage object.\n\t * Reactive values will always be raw.\n\t * @returns {object}\n\t */\n\tget storage () {\n\t\tthis._rio?.depend();\n\t\treturn this._storage;\n\t}\n\n\t/**\n\t * Returns a reversed shallow copy.\n\t * @returns {NANOS}\n\t */\n\ttoReversed () {\n\t\tthis._rio?.depend();\n\t\treturn this.similar().from(this).reverse();\n\t}\n\n\t/**\n\t * Returns a JSON-representable object.\n\t * Might be the best we can do.\n\t * @returns {{type: string, next: number, pairs: Array<*>}}\n\t */\n\ttoJSON () {\n\t\tthis._rio?.depend();\n\t\treturn {type:'@NANOS@', next: this._next, pairs: this.pairs(true)};\n\t}\n\n\t/**\n\t * Generate SLID (SysCL List Data)-format string.\n\t * @param {{compact?: boolean, redact?: boolean}} [options]\n\t * @returns {string}\n\t */\n\ttoSLID ({ compact = false, redact = false } = {}) {\n\t\tthis._rio?.depend();\n\t\tconst escape = (str) => escapeJSString(str).replace(/\\)]/g, ')\\\\]');\n\t\tconst squished = (items) => {\n\t\t\tconst parts = [];\n\t\t\tfor (const item of items) {\n\t\t\t\tconst tail = parts.length ? parts.slice(-1).slice(-1) : '';\n\t\t\t\tconst joint = tail + (item[0] || '')/* head */;\n\t\t\t\tif (tail && !/['\"\\[\\]]/.test(joint)) parts.push(' ');\n\t\t\t\tparts.push(item);\n\t\t\t}\n\t\t\treturn parts.join('');\n\t\t};\n\t\tconst valueToStr = (value) => {\n\t\t\tswitch (value) {\n\t\t\tcase false: return '@f';\n\t\t\tcase null: return '@n';\n\t\t\tcase true: return '@t';\n\t\t\tcase undefined: return '@u';\n\t\t\t}\n\t\t\tswitch (typeof value) {\n\t\t\tcase 'bigint': return value.toString() + 'n';\n\t\t\tcase 'number': return value.toString();\n\t\t\tcase 'string':\n\t\t\t\t// Word-literal or quoted string\n\t\t\t\tif (/^[~!#$%^&*()+.,:;<>?A-Z{}_][~!@#$%^&*()+.,0-9:;<>?A-Z{}_-]*$/i.test(value)) return value;\n\t\t\t\treturn \"'\" + escape(value) + \"'\";\n\t\t\t}\n\t\t\tif (isPlainObject(value) || Array.isArray(value) || value instanceof Map || value instanceof Set) value = new this.constructor(value);\n\t\t\tif (value instanceof NANOS) return '[' + itemsToStr(value) + ']';\n\t\t\treturn '@u/*??*/';\n\t\t};\n\t\tconst itemsToStr = (node) => {\n\t\t\tlet expInd = 0;\t\t\t\t\t\t// Expected next index\n\t\t\tif (redact && node._redacted === true) return ((redact === 'comment') ? '/*???*/' : '');\n\t\t\tconst items = [];\n\t\t\tfor (const en of node.entries()) {\n\t\t\t\tif (isIndex(en[0])) {\n\t\t\t\t\tif (redact && node.isRedacted(0)) {\n\t\t\t\t\t\tif (redact === 'comment') items.push('/*?*/');\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst ind = parseInt(en[0], 10);\n\t\t\t\t\titems.push(((ind === expInd) ? '' : `${ind}=`) + valueToStr(en[1]));\n\t\t\t\t\texpInd = ind + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (redact && node.isRedacted(en[0])) {\n\t\t\t\t\t\tif (redact === 'comment') items.push('/*?=?*/');\n\t\t\t\t\t} else items.push(valueToStr(en[0]) + '=' + valueToStr(en[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (compact ? squished(items) : items.join(' '));\n\t\t};\n\t\treturn '[(' + itemsToStr(this).replace(/\\)\\]/g, ')\\\\]') + ')]';\n\t}\n\n\tstatic toSLID (value, options = {}) {\n\t\tif (value instanceof NANOS) return value.toSLID(options);\n\t\telse return ((new NANOS(value)).toSLID(options));\n\t}\n\n\t/**\n\t * Converts to a string (SLID format).\n\t * @param {object} [options]\n\t * @returns {string}\n\t */\n\ttoString (options = {}) {\n\t\treturn this.toSLID({ redact: true, ...options });\n\t}\n\n\t/**\n\t * Prepends new elements.\n\t * Unshift works like push, except that indexed values are offset-from-0\n\t * inserted instead (preserving sparseness except for transform sets).\n\t * @param {...*} items\n\t * @returns {this}\n\t */\n\tunshift (...values) {\n\t\tif (this._locked) throw new TypeError('NANOS: Cannot \"unshift\" after locking');\n\t\tif (this._lockInd) throw new TypeError('NANOS: Cannot \"unshift\" after index lock');\n\t\tconst batch = this._rio?.batch || ((cb) => cb());\n\t\tbatch(() => values.toReversed().forEach((outer) => {\n\t\t\tif (!(outer instanceof NANOS)) outer = this.similar(outer);\n\t\t\tthis.#renumber(0, this._next, outer.next);\n\t\t\tthis.fromEntries(outer.entries(), true);\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return a (sparse) iterator of *indexed* values.\n\t * @param {object} [opts] Options object\n\t * @param {boolean} [opts.raw] Yields raw, rather than final, reactive values\n\t * @yields {*}\n\t */\n\t*values (opts = {}) {\n\t\tthis._rio?.depend();\n\t\tconst toFinal = (opts.raw || !this._rio?.get) ? ((v) => v) : ((v) => this.#final(v));\n\t\tfor (const index of this.indexKeys()) yield toFinal(this.atRaw(index));\n\t}\n\n\t/**\n\t * Internal method to handle negative indices.\n\t * @param {string|number} key\n\t * @returns {string|number|undefined}\n\t */\n\t#wrapKey (key) {\n\t\tif (isNegIndex(key)) {\n\t\t\tkey = parseInt(key, 10) + this._next;\n\t\t\tif (key < 0) return;\n\t\t}\n\t\treturn key;\n\t}\n}\n\n// Alias .get() to .at()\nNANOS.prototype.get = NANOS.prototype.at;\n// Alias .setOpts() to .setOptions()\nNANOS.prototype.setOptions = NANOS.prototype.setOpts;\n\n// Make parseQJSON and parseSLID directly importable\nexport const { parseQJSON, parseSLID, toSLID } = NANOS;\nexport { NANOS as default };\n\n// END\n"],
  "mappings": "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",
  "names": ["escapeJSString", "unescapeJSString", "slidPats", "slidRE", "k", "slidNum", "qjMap", "isIndex", "key", "isNegIndex", "isPlainObject", "value", "consName", "NANOS", "items", "opts", "#getOpts", "next", "curKey", "#final", "#wrapKey", "ret", "_key", "skey", "storage", "ik", "fv", "v", "f", "result", "kv", "toFinal", "final", "source", "cb", "entries", "insert", "e", "pairs", "batch", "end", "i", "optParam", "defKey", "defOpts", "optObj", "keys", "andNew", "#mapish", "nn", "str", "parseSLID", "s", "c", "qj", "match", "tokens", "t", "parseLeft", "token", "parseRight", "parseItems", "values", "options", "transform", "pushEntries", "base", "minNext", "newKey", "#setish", "mergeMaps", "pushInner", "pushOuter", "outer", "#renumber", "from", "to", "by", "move", "ind", "nks", "ns", "last", "ok", "nk", "r", "changed", "ki", "res", "compact", "redact", "escape", "squished", "parts", "item", "tail", "joint", "valueToStr", "itemsToStr", "node", "expInd", "en", "index", "parseQJSON", "toSLID"]
}
