import{escapeJSString as p,unescapeJSString as g}from"./vendor/escape-js.esm.js";const u={mlc:"/\\*.*?\\*/",flt:"[+-]?\\d+(?:[.]\\d+)?(?:[eE][+-]?\\d+)?(?![0-9a-zA-Z])",int:"[+-]?(?:0[bB][01]+|0[oO][0-7]+|0[xX][0-9a-fA-F]+|\\d+)n?(?![0-9a-zA-Z])",sqs:"'(?:\\\\'|[^'])*'",dqs:'"(?:\\\\"|[^"])*"',stok:"[[=\\]]",spc:"\\s+",oth:`(?:[^'"/[=\\]\\s]|\\/(?![*]))+`},k=new RegExp("("+"mlc flt int sqs dqs stok spc oth".split(" ").map(l=>u[l]).join("|")+")","s"),x=new RegExp(`^(${u.flt}|${u.int})$`),w={"{":"[","}":"]",",":" ",":":"="},f=l=>/^(?:0|[1-9]\d*)$/.test(l),y=l=>/^-[1-9]\d*$/.test(l);class a{constructor(...t){this.clear(),this.push(...t)}at(t,e){return this._rio?.depend(),t=this.#t(t),Object.hasOwn(this._storage,t)?this._storage[t]:e}get autoPromote(){return this._autoPromote}set autoPromote(t){this._autoPromote=t}clear(){if(this._locked)throw new TypeError("NANOS: Cannot clear after locking");return this._next=0,this._keys=[],this._storage={},this._lockInd=void 0,delete this._redacted,this._rio?.changed(),this}deepFreeze(){this.freeze();for(const[t,e]of this.entries())e instanceof a&&e.deepFreeze();return this}delete(t){if(this._locked)throw new TypeError("NANOS: Cannot delete after locking");const e=""+t,s=this._storage[e];return Object.hasOwn(this._storage,e)&&(delete this._storage[e],this._keys=this._keys.filter(i=>i!==e),this._rio?.changed()),s}depend(){this._rio?.depend()}*entries(t=!1){this._rio?.depend();const e=t?s=>f(s)?parseInt(s,10):s:s=>s;for(const s of this._keys)yield[e(s),this._storage[s]]}filter(t){return this._rio?.depend(),new a.fromEntries([...this.entries()].filter(e=>t(e[1],e[0],this)))}find(t){this._rio?.depend();const e=this._storage;for(const s of this._keys)if(t(e[s],s,this))return[s,e[s]]}findLast(t){this._rio?.depend();const e=this._storage;for(const s of this._keys.toReversed())if(t(e[s],s,this))return[s,e[s]]}forEach(t){this._rio?.depend();for(const e of this._keys)t(this._storage[e],e,this)}freeze(){return Object.isFrozen(this)||(this._locked=!0,this._lockInd=!0,Object.freeze(this)),Object.freeze(this._keys),Object.freeze(this._storage),typeof this._redacted=="object"&&Object.freeze(this._redacted),this}fromEntries(t,e=!1){if(this._locked)throw new TypeError("NANOS: Cannot fromEntries after locking");if(e&&this._lockInd)throw new TypeError("NANOS: Cannot insert fromEntries after index lock");return(this._rio?.batch||(i=>i()))(()=>{if(e)for(const i of[...t].reverse())this.set(i[0],i[1],!0);else for(const i of t)this.set(i[0],i[1]);this._rio?.changed()}),this}fromPairs(...t){if(this._locked)throw new TypeError("NANOS: Cannot fromPairs after locking");const e=this._rio?.batch||(i=>i());if(t[0]?.type==="@NANOS@")return e(()=>{this.fromPairs(t[0].pairs),this.next=t[0].next,this._rio?.changed()}),this;Array.isArray(t[0])&&(t=t[0]);const s=t.length-1;return e(()=>{for(let i=0;i<s;i+=2)t[i]===void 0&&!(i+1 in t)?++this._next:this.set(t[i],t[i+1]);this._rio?.changed()}),this}has(t){return this._rio?.depend(),Object.hasOwn(this._storage,this.#t(t))}includes(t){return this.keyOf(t)!==void 0}*indexEntries(t=!1){for(const e of this.entries(t))f(e[0])&&(yield e)}*indexKeys(){this._rio?.depend();for(const t of this._keys)f(t)&&(yield t)}isLocked(t){return this._rio?.depend(),t===void 0?this._locked:(t=this.#t(t),this._locked&&!Object.hasOwn(this._storage,t)?!0:!Object.getOwnPropertyDescriptor(this._storage,t)?.writable)}isRedacted(t){return this._rio?.depend(),this._redacted===!0?!0:(t=this.#t(t),f(t)?this._redacted?.[0]:this._redacted?.[t])}keyOf(t){return this.find(e=>e===t)?.[0]}keys(){return this._rio?.depend(),this._keys.values()}lastKeyOf(t){return this.findLast(e=>e===t)?.[0]}lock(...t){typeof t[0]=="object"&&(key=t[0]);for(let e of t)e=this.#t(e),f(e)&&(this._lockInd=!0),e!==void 0&&Object.defineProperty(this._storage,e,{value:this.at(e),enumerable:!0,writable:!1,configurable:!1});return this._rio?.changed(),this}lockAll(t=!1){return t&&(this._lockNew=!0),this.lock(this._keys.values()),this}lockKeys(){return this._locked=!0,this._rio?.changed(),this}*namedEntries(){for(const t of this.entries())f(t[0])||(yield t)}*namedKeys(){for(const t of this.entries())f(t[0])||(yield t[0])}get next(){return this._rio?.depend(),this._next}set next(t){if(this._locked)throw new TypeError("NANOS: Cannot set next after locking");if(!(!Number.isInteger(t)||t<0)){for(let e=this._next;--e>=t;this.delete(e));this._next!==t&&(this._next=t,this._rio?.changed())}}pairs(t=!1){return[...this.entries(t)].flat(1)}static parseQJSON(t){return m("[("+t.replaceAll(/^\s*[\[\{]?|[\]\}]\s*$/g,"").split(/("(?:\\\\"|[^"])*")/).map(e=>e[0]==='"'?e:e.replace(/[{},:]/g,s=>w[s])).join("")+")]",!0)}static parseSLID(t,e=!1){let s=t.match(/\[\((.*?)\)\]/s);if(!s)throw new SyntaxError("Missing SLID boundary marker(s)");const i=s[1].replace(/\)\\\]/g,")]").split(k).filter(o=>!/^(\s*|\/\*.*\*\/)$/.test(o));s=void 0;const r=()=>{const o=i.shift();if(x.test(o))return/n$/i.test(o)?BigInt(o.slice(0,-1)):/^[+-]?0b/i.test(o)?parseInt(o.replace(/0b/i,""),2):/^[+-]?0o/i.test(o)?parseInt(o.replace(/0o/i,""),8):/^[+-]?0x/i.test(o)?parseInt(o.replace(/0x/i,""),16):parseFloat(o);if(o==="'"||o==='"')throw new SyntaxError(`Unmatched ${o} in SLID`);return o[0]!=="'"&&o[0]!=='"'?o:g(o.slice(1,-1))},h=()=>{if(i[0]!=="["){if(!e)switch(i[0]){case"@f":return i.shift(),!1;case"@n":return i.shift(),null;case"@t":return i.shift(),!0;case"@u":i.shift();return}return r()}return i.shift(),n()};function n(){const o=new a;for(;i.length&&i[0]!=="]";){let c;if(i[1]==="=")c=r(),i.shift();else if(!e&&i[0]==="@e"){i.shift(),++o.next;continue}o.set(c,h())}return i[0]==="]"&&i.shift(),o}const d=n();if(i.length)throw new SyntaxError("Malformed SLID");return d}pop(){if(this._locked)throw new TypeError("NANOS: Cannot pop after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot pop after index lock");if(this._next)return this.delete(--this._next)}push(...t){if(this._locked)throw new TypeError("NANOS: Cannot push after locking");return(this._rio?.batch||(s=>s()))(()=>t.forEach(s=>{const i=this._next;if(s instanceof a||s instanceof Map)for(const r of s.entries())f(r[0])?this.set(i+parseInt(r[0],10),r[1]):this.set(r[0],r[1]);else if(s instanceof Set)this.push(...s);else if(typeof s=="object")for(const r of Object.keys(s))f(r)?this.set(i+parseInt(r,10),s[r]):this.set(r,s[r]);else this.set(this._next,s)})),this}redact(...t){for(const e of t){if(e===!0&&(this._redacted=!0),this._redacted===!0)return;this._redacted||={},f(e)?this._redacted[0]=!0:this._redacted[e]=!0}return this._rio?.changed(),this}#e(t,e,s){const i=(r,h)=>{Object.hasOwn(this._storage,r)&&(this._storage[r+h]=this._storage[r],delete this._storage[r])};if(s>0){e+s>this._next&&(this._next=e+s);for(let r=e;--r>=t;)i(r,s)}else if(s<0){e>=this._next&&(this._next+=s);for(let r=t;r<e;++r)i(r,s)}s&&(this._keys=this._keys.map(r=>{const h=f(r)&&parseInt(r,10);return h!==!1&&h>=t&&h<e?h+s+"":r}))}reverse(){if(this._locked)throw new TypeError("NANOS: Cannot reverse after locking");const t=this._storage,e=[],s={},i=this._next-1;for(const r of this._keys.toReversed()){const h=f(r)?i-r:r;s[h]=t[r],e.push(h)}return this._storage=s,this._keys=e,this._rio?.changed(),this}get rio(){return this._rio}set rio(t){t?t?.batch&&t.changed&&t.create&&t.depend&&(this._rio=t):delete this._rio}set(t,e,s=!1){if(this._locked)throw new TypeError("NANOS: Cannot set after locking");if(t===void 0&&(t=this._next),t=this.#t(t),t===void 0)return;const i=""+t,r=f(i)&&parseInt(i,10);let h=!1;if(!Object.hasOwn(this._storage,i)){if(h=!0,s)if(r===!1||!this._next)this._keys.unshift(i);else{let n=this._keys.length;for(;n>0&&(!f(this._keys[n-1])||r<this._keys[n-1]);)--n;this._keys.splice(n,0,i)}else if(r===!1||r>=this._next)this._keys.push(i);else{let n=0;for(;n<this._keys.length&&(!f(this._keys[n])||r>this._keys[n]);)++n;this._keys.splice(n,0,i)}r!==!1&&r>=this._next&&(this._next=r+1)}if(typeof e=="object"&&this._autoPromote&&e!==null)switch(e?.constructor?.name){case void 0:case"Array":case"Object":this._storage[i]=this.similar(e);break;default:this._storage[i]=e;break}else this._storage[i]=e;return this._lockNew&&this.lock(i),h&&this._rio?.changed(),e}setAutoPromote(t){return this._autoPromote=t,this}setRIO(t){return this.rio=t,this}shift(){if(this._locked)throw new TypeError("NANOS: Cannot shift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot shift after index lock");return this._next?(this._rio?.batch||(e=>e()))(()=>{const e=this.delete(0);return this.#e(1,this._next,-1),e}):void 0}get size(){return this._rio?.depend(),this._keys.length}similar(...t){const e=new a;return this._autoPromote&&(e.autoPromote=!0),e.rio=this._rio?.create(),t.length&&e.push(...t),e}get storage(){return this._rio?.depend(),this._storage}toReversed(){return this._rio?.depend(),this.similar().fromPairs(this.toJSON()).reverse()}toJSON(){return this._rio?.depend(),{type:"@NANOS@",next:this._next,pairs:this.pairs(!0)}}toSLID({compact:t=!1,redact:e=!1}={}){this._rio?.depend();const s=n=>p(n).replace(/\)]/g,")\\]");function i(n){const d=[];for(const o of n){const c=d.length?d.slice(-1).slice(-1):"",_=c+(o[0]||"");c&&!/['"\[\]]/.test(_)&&d.push(" "),d.push(o)}return d.join("")}function r(n){switch(n){case!1:return"@f";case null:return"@n";case!0:return"@t";case void 0:return"@u"}switch(typeof n){case"bigint":return n.toString()+"n";case"number":return n.toString();case"string":return/^[!()*.,:;<>?A-Z{}_][!()*.,0-9:;<>?@A-Z{}_-]*$/i.test(n)?n:"'"+s(n)+"'"}return n instanceof a?"["+h(n)+"]":"@u/*??*/"}function h(n){let d=0;if(e&&n._redacted===!0)return e==="comment"?"/*???*/":"";const o=[];for(const c of n.entries())if(f(c[0])){if(e&&n.isRedacted(0)){e==="comment"&&o.push("/*?*/");continue}const _=parseInt(c[0],10);o.push((_===d?"":`${_}=`)+r(c[1])),d=_+1}else e&&n.isRedacted(c[0])?e==="comment"&&o.push("/*?=?*/"):o.push(r(c[0])+"="+r(c[1]));return t?i(o):o.join(" ")}return"[("+h(this).replace(/\)\]/g,")\\]")+")]"}toString(t={}){return this.toSLID({redact:!0,...t})}unshift(...t){if(this._locked)throw new TypeError("NANOS: Cannot unshift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot unshift after index lock");return(this._rio?.batch||(s=>s()))(()=>t.toReversed().forEach(s=>{if(s instanceof a)this.#e(0,this._next,s.next),this.fromEntries(s.entries(),!0);else if(s instanceof Map){const i=Array.from(s.keys()).filter(r=>f(r)).reduce((r,h)=>Math.max(r,h),-1)+1;this.#e(0,this._next,i),this.fromEntries(s.entries(),!0)}else if(s instanceof Set)this.unshift(...s);else if(typeof s=="object"){const i=Array.isArray(s)?s.length:Object.keys(s).filter(r=>f(r)).reduce((r,h)=>Math.max(r,h),-1)+1;this.#e(0,this._next,i),this.fromEntries(Object.entries(s),!0)}else this.unshift([s])})),this}*values(){this._rio?.depend();for(let t=0;t<this._next;++t)yield this.at(t)}#t(t){if(!(y(t)&&(t=parseInt(t,10)+this._next,t<0)))return t}}a.prototype.get=a.prototype.at;const{parseQJSON:O,parseSLID:m}=a;export{a as NANOS,a as default,f as isIndex,y as isNegIndex,O as parseQJSON,m as parseSLID};
