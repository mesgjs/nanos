import{escapeJSString as y,unescapeJSString as m}from"./vendor/escape-js.esm.js";const k={mlc:"/\\*.*?\\*/",flt:"[+-]?\\d+(?:[.]\\d+)?(?:[eE][+-]?\\d+)?(?![0-9a-zA-Z])",int:"[+-]?(?:0[bB][01]+|0[oO][0-7]+|0[xX][0-9a-fA-F]+|\\d+)n?(?![0-9a-zA-Z])",sqs:"'(?:\\\\'|[^'])*'",dqs:'"(?:\\\\"|[^"])*"',stok:"[[=\\]]",spc:"\\s+",oth:`(?:[^'"/[=\\]\\s]|\\/(?![*]))+`},O=new RegExp("("+"mlc flt int sqs dqs stok spc oth".split(" ").map(l=>k[l]).join("|")+")","s"),S=new RegExp(`^(${k.flt}|${k.int})$`),b={"{":"[","}":"]",",":" ",":":"="},c=l=>/^(?:0|[1-9]\d*)$/.test(l),I=l=>/^-[1-9]\d*$/.test(l),p=l=>{if(typeof l!="object"||l===null)return!1;const t=l?.constructor?.name;return t===void 0||t==="Object"};class d{constructor(...t){this._options={},this.clear(),this.push(...t)}at(t,e){if(Array.isArray(t)){let s=this;for(const i of t){if(!(s instanceof d)||!s.has(i))return e;s=s.at(i)}return s}return this._rio?.depend(),t=this.#t(t),Object.hasOwn(this._storage,t)?this._storage[t]:e}clear(){if(this._locked)throw new TypeError("NANOS: Cannot clear after locking");return this._next=0,this._keys=[],this._storage={},this._lockInd=void 0,delete this._redacted,this._rio?.changed(),this}deepFreeze(){this.freeze();for(const[t,e]of this.entries())e instanceof d&&e.deepFreeze();return this}delete(t){if(this._locked)throw new TypeError("NANOS: Cannot delete after locking");const e=String(t),s=this._storage[e];return Object.hasOwn(this._storage,e)&&(delete this._storage[e],this._keys=this._keys.filter(i=>i!==e),this._rio?.changed()),s}depend(){this._rio?.depend()}*entries(t=!1){this._rio?.depend();const e=t?s=>c(s)?parseInt(s,10):s:s=>s;for(const s of this._keys)yield[e(s),this._storage[s]]}filter(t){this._rio?.depend();const e=new this.constructor;return e.fromEntries([...this.entries()].filter(s=>t(s[1],s[0],this))),e}find(t){this._rio?.depend();const e=this._storage;for(const s of this._keys)if(t(e[s],s,this))return[s,e[s]]}findLast(t){this._rio?.depend();const e=this._storage;for(const s of this._keys.toReversed())if(t(e[s],s,this))return[s,e[s]]}forEach(t){this._rio?.depend();for(const e of this._keys)t(this._storage[e],e,this)}freeze(){return Object.isFrozen(this)||(this._locked=!0,this._lockInd=!0,Object.freeze(this)),Object.freeze(this._keys),Object.freeze(this._storage),typeof this._redacted=="object"&&Object.freeze(this._redacted),this}fromEntries(t,e=!1){if(this._locked)throw new TypeError("NANOS: Cannot fromEntries after locking");if(e&&this._lockInd)throw new TypeError("NANOS: Cannot insert fromEntries after index lock");return(this._rio?.batch||(i=>i()))(()=>{if(e)for(const i of[...t].reverse())this.set(i[0],i[1],!0);else for(const i of t)this.set(i[0],i[1]);this._rio?.changed()}),this}fromPairs(...t){if(this._locked)throw new TypeError("NANOS: Cannot fromPairs after locking");const e=this._rio?.batch||(i=>i());if(p(t[0])&&t[0].type==="@NANOS@")return e(()=>{this.fromPairs(t[0].pairs),this.next=t[0].next,this._rio?.changed()}),this;Array.isArray(t[0])&&(t=t[0]);const s=t.length-1;return e(()=>{for(let i=0;i<s;i+=2)t[i]===void 0&&!(i+1 in t)?++this._next:this.set(t[i],t[i+1]);this._rio?.changed()}),this}has(t){return this._rio?.depend(),Object.hasOwn(this._storage,this.#t(t))}includes(t){return this.keyOf(t)!==void 0}*indexEntries(t=!1){for(const e of this.entries(t))c(e[0])&&(yield e)}*indexKeys(){this._rio?.depend();for(const t of this._keys)c(t)&&(yield t)}isLocked(t){return this._rio?.depend(),t===void 0?!!this._locked:(t=this.#t(t),this._locked&&!Object.hasOwn(this._storage,t)?!0:!Object.getOwnPropertyDescriptor(this._storage,t)?.writable)}isRedacted(t){return this._rio?.depend(),this._redacted===!0?!0:(t=this.#t(t),c(t)?!!this._redacted?.[0]:!!this._redacted?.[t])}keyOf(t){return this.find(e=>e===t)?.[0]}keys(){return this._rio?.depend(),this._keys.values()}lastKeyOf(t){return this.findLast(e=>e===t)?.[0]}lock(...t){t.length===1&&Array.isArray(t[0])&&(t=t[0]);for(let e of t)e=this.#t(e),c(e)&&(this._lockInd=!0),e!==void 0&&Object.defineProperty(this._storage,e,{value:this.at(e),enumerable:!0,writable:!1,configurable:!1});return this._rio?.changed(),this}lockAll(t=!1){return t&&(this._lockNew=!0),this.lock(this._keys),this}lockKeys(){return this._locked=!0,this._rio?.changed(),this}#e(t){return p(t)||!this._options.opaqueMaps&&t instanceof Map}*namedEntries(){for(const t of this.entries())c(t[0])||(yield t)}*namedKeys(){for(const t of this.entries())c(t[0])||(yield t[0])}get next(){return this._rio?.depend(),this._next}set next(t){if(this._locked)throw new TypeError("NANOS: Cannot set next after locking");if(!(!Number.isInteger(t)||t<0)){for(let e=this._next;--e>=t;this.delete(e));this._next!==t&&(this._next=t,this._rio?.changed())}}get options(){return Object.assign({},this._options)}pairs(t=!1){return[...this.entries(t)].flat(1)}static parseQJSON(t){return N("[("+t.replaceAll(/^\s*[\[\{]?|[\]\}]\s*$/g,"").split(/("(?:\\\\"|[^"])*")/).map(e=>e[0]==='"'?e:e.replace(/[{},:]/g,s=>b[s])).join("")+")]",!0)}static parseSLID(t,e=!1){let s=t.match(/\[\((.*?)\)\]/s);if(!s)throw new SyntaxError("Missing SLID boundary marker(s)");const i=s[1].replace(/\)\\\]/g,")]").split(O).filter(r=>!/^(\s*|\/\*.*\*\/)$/.test(r));s=void 0;const o=()=>{const r=i.shift();if(S.test(r))return/n$/i.test(r)?BigInt(r.slice(0,-1)):/^[+-]?0b/i.test(r)?parseInt(r.replace(/0b/i,""),2):/^[+-]?0o/i.test(r)?parseInt(r.replace(/0o/i,""),8):/^[+-]?0x/i.test(r)?parseInt(r.replace(/0x/i,""),16):parseFloat(r);if(r==="'"||r==='"')throw new SyntaxError(`Unmatched ${r} in SLID`);return r[0]!=="'"&&r[0]!=='"'?r:m(r.slice(1,-1))},h=()=>{if(i[0]!=="["){if(e)switch(i[0]){case"false":return i.shift(),!1;case"null":return i.shift(),null;case"true":return i.shift(),!0}else switch(i[0]){case"@f":return i.shift(),!1;case"@n":return i.shift(),null;case"@t":return i.shift(),!0;case"@u":i.shift();return}return o()}return i.shift(),n.call(this)},n=()=>{const r=new d;for(;i.length&&i[0]!=="]";){let f;if(i[1]==="=")f=o(),i.shift();else if(!e&&i[0]==="@e"){i.shift(),++r.next;continue}r.set(f,h())}return i[0]==="]"&&i.shift(),r},u=n();if(i.length)throw new SyntaxError("Malformed SLID");return u}pop(){if(this._locked)throw new TypeError("NANOS: Cannot pop after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot pop after index lock");if(this._next)return this.delete(--this._next)}push(...t){if(this._locked)throw new TypeError("NANOS: Cannot push after locking");const e=this._rio?.batch||(r=>r()),s=this._options,i=s.transform,o=(r,f=0)=>{const a=this._next,w=a+f;for(let[g,_]of r)if(c(g)){const x=a+parseInt(g,10);i&&(this.#e(_)||this.#s(_))&&(_=this.similar(_)),this.set(x,_)}else this.set(g,_);this._next<w&&(this._next=w)},h=r=>{for(let[f,a]of r)c(f)?this.#e(a)?h(new this.constructor(a).entries()):(this.#s(a)&&(a=this.similar(a)),this.set(void 0,a)):this.set(f,a)},n=i==="sets"?h:o,u=r=>{p(r)?n(Object.entries(r)):Array.isArray(r)?n(Object.entries(r),r.length):r instanceof d?n(r.entries(),r.next):!s.opaqueMaps&&r instanceof Map?n(r.entries()):!s.opaqueSets&&r instanceof Set?n([...r.values()].entries()):this.set(void 0,r)};return e(()=>t.forEach(u)),this}redact(...t){for(const e of t){if(e===!0&&(this._redacted=!0),this._redacted===!0)return;this._redacted||={},c(e)?this._redacted[0]=!0:this._redacted[e]=!0}return this._rio?.changed(),this}#i(t,e,s){const i=(o,h)=>{Object.hasOwn(this._storage,o)&&(this._storage[o+h]=this._storage[o],delete this._storage[o])};if(s>0){e+s>this._next&&(this._next=e+s);for(let o=e;--o>=t;)i(o,s)}else if(s<0){e>=this._next&&(this._next+=s);for(let o=t;o<e;++o)i(o,s)}s&&(this._keys=this._keys.map(o=>{const h=c(o)&&parseInt(o,10);return h!==!1&&h>=t&&h<e?h+s+"":o}))}reverse(){if(this._locked)throw new TypeError("NANOS: Cannot reverse after locking");const t=this._storage,e=[],s={},i=this._next-1;for(const o of this._keys.toReversed()){const h=c(o)?String(i-parseInt(o,10)):o;s[h]=t[o],e.push(h)}return this._storage=s,this._keys=e,this._rio?.changed(),this}*reverseEntries(t=!1){this._rio?.depend();const e=t?s=>c(s)?parseInt(s,10):s:s=>s;for(const s of this._keys.toReversed())yield[e(s),this._storage[s]]}get rio(){return this._rio}set rio(t){t?t?.batch&&t.changed&&t.create&&t.depend&&(this._rio=t):delete this._rio}set(t,e,s=!1){if(this._locked)throw new TypeError("NANOS: Cannot set after locking");if(t===void 0&&(t=this._next),t=this.#t(t),t===void 0)return;const i=String(t),o=c(i)&&parseInt(i,10);let h=!1;if(!Object.hasOwn(this._storage,i)){if(h=!0,s)if(o===!1||!this._next)this._keys.unshift(i);else{let n=this._keys.length;for(;n>0&&(!c(this._keys[n-1])||o<this._keys[n-1]);)--n;this._keys.splice(n,0,i)}else if(o===!1||o>=this._next)this._keys.push(i);else{let n=0;for(;n<this._keys.length&&(!c(this._keys[n])||o>this._keys[n]);)++n;this._keys.splice(n,0,i)}o!==!1&&o>=this._next&&(this._next=o+1)}return this._options.transform&&(this.#s(e)||this.#e(e))?this._storage[i]=this.similar(e):this._storage[i]=e,this._lockNew&&this.lock(i),h&&this._rio?.changed(),e}#s(t){return Array.isArray(t)||!this._options.opaqueSets&&t instanceof Set}setOptions(t){return Object.assign(this._options,t),this}setRIO(t){return this.rio=t,this}shift(){if(this._locked)throw new TypeError("NANOS: Cannot shift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot shift after index lock");return this._next?(this._rio?.batch||(e=>e()))(()=>{const e=this.delete(0);return this.#i(1,this._next,-1),e}):void 0}get size(){return this._rio?.depend(),this._keys.length}similar(...t){const e=new this.constructor;return e.setOptions(this._options),e.rio=this._rio?.create(),t.length&&e.push(...t),e}get storage(){return this._rio?.depend(),this._storage}toReversed(){return this._rio?.depend(),this.similar().fromPairs(this.toJSON()).reverse()}toJSON(){return this._rio?.depend(),{type:"@NANOS@",next:this._next,pairs:this.pairs(!0)}}toSLID({compact:t=!1,redact:e=!1}={}){this._rio?.depend();const s=n=>y(n).replace(/\)]/g,")\\]");function i(n){const u=[];for(const r of n){const f=u.length?u.slice(-1).slice(-1):"",a=f+(r[0]||"");f&&!/['"\[\]]/.test(a)&&u.push(" "),u.push(r)}return u.join("")}function o(n){switch(n){case!1:return"@f";case null:return"@n";case!0:return"@t";case void 0:return"@u"}switch(typeof n){case"bigint":return n.toString()+"n";case"number":return n.toString();case"string":return/^[!()*.,:;<>?A-Z{}_][!()*.,0-9:;<>?@A-Z{}_-]*$/i.test(n)?n:"'"+s(n)+"'"}return(p(n)||Array.isArray(n)||n instanceof Map||n instanceof Set)&&(n=new this.constructor(n)),n instanceof d?"["+h(n)+"]":"@u/*??*/"}function h(n){let u=0;if(e&&n._redacted===!0)return e==="comment"?"/*???*/":"";const r=[];for(const f of n.entries())if(c(f[0])){if(e&&n.isRedacted(0)){e==="comment"&&r.push("/*?*/");continue}const a=parseInt(f[0],10);r.push((a===u?"":`${a}=`)+o(f[1])),u=a+1}else e&&n.isRedacted(f[0])?e==="comment"&&r.push("/*?=?*/"):r.push(o(f[0])+"="+o(f[1]));return t?i(r):r.join(" ")}return"[("+h(this).replace(/\)\]/g,")\\]")+")]"}toString(t={}){return this.toSLID({redact:!0,...t})}unshift(...t){if(this._locked)throw new TypeError("NANOS: Cannot unshift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot unshift after index lock");return(this._rio?.batch||(s=>s()))(()=>t.toReversed().forEach(s=>{s instanceof d||(s=this.similar(s)),this.#i(0,this._next,s.next),this.fromEntries(s.entries(),!0)})),this}*values(){this._rio?.depend();for(const t of this.indexKeys())yield this.at(t)}#t(t){if(!(I(t)&&(t=parseInt(t,10)+this._next,t<0)))return t}}d.prototype.get=d.prototype.at,d.toSLID=(l,t={})=>l instanceof d?l.toSLID(t):new d(l).toSLID(t);const{parseQJSON:A,parseSLID:N,toSLID:j}=d;export{d as NANOS,d as default,c as isIndex,I as isNegIndex,A as parseQJSON,N as parseSLID,j as toSLID};
