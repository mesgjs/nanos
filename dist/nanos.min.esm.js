import{escapeJSString as t,unescapeJSString as e}from"escape-js/escape.esm.js";const s=t=>/^(?:0|[1-9]\d*)$/.test(t),r=t=>/^-[1-9]\d*$/.test(t);class i{constructor(...t){this.clear(),this.push(...t)}at(t,e){return this._rio?.depend(),t=this.#t(t),Object.hasOwn(this._storage,t)?this._storage[t]:e}get autoPromote(){return this._autoPromote}set autoPromote(t){this._autoPromote=t}clear(){if(this._locked)throw new TypeError("NANOS: Cannot clear after locking");return this._next=0,this._keys=[],this._storage={},this._lockInd=void 0,delete this._redacted,this._rio?.changed(),this}delete(t){if(this._locked)throw new TypeError("NANOS: Cannot delete after locking");const e=""+t,s=this._storage[e];return Object.hasOwn(this._storage,e)&&(delete this._storage[e],this._keys=this._keys.filter((t=>t!==e)),this._rio?.changed()),s}depend(){this._rio?.depend()}*entries(t=!1){this._rio?.depend();const e=t?t=>s(t)?parseInt(t,10):t:t=>t;for(const t of this._keys)yield[e(t),this._storage[t]]}filter(t){return this._rio?.depend(),new i.fromEntries([...this.entries()].filter((e=>t(e[1],e[0],this))))}find(t){this._rio?.depend();const e=this._storage;for(const s of this._keys)if(t(e[s],s,this))return[s,e[s]]}findLast(t){this._rio?.depend();const e=this._storage;for(const s of this._keys.toReversed())if(t(e[s],s,this))return[s,e[s]]}forEach(t){this._rio?.depend();for(const e of this._keys)t(this._storage[e],e,this)}fromEntries(t,e=!1){if(this._locked)throw new TypeError("NANOS: Cannot fromEntries after locking");if(e&&this._lockInd)throw new TypeError("NANOS: Cannot insert fromEntries after index lock");return(this._rio?.batch||(t=>t()))((()=>{if(e)for(const e of[...t].reverse())this.set(e[0],e[1],!0);else for(const e of t)this.set(e[0],e[1]);this._rio?.changed()})),this}fromPairs(...t){if(this._locked)throw new TypeError("NANOS: Cannot fromPairs after locking");const e=this._rio?.batch||(t=>t());if("@NANOS@"===t[0]?.type)return e((()=>{this.fromPairs(t[0].pairs),this.next=t[0].next,this._rio?.changed()})),this;Array.isArray(t[0])&&(t=t[0]);const s=t.length-1;return e((()=>{for(let e=0;e<s;e+=2)void 0!==t[e]||e+1 in t?this.set(t[e],t[e+1]):++this._next;this._rio?.changed()})),this}has(t){return this._rio?.depend(),Object.hasOwn(this._storage,this.#t(t))}includes(t){return void 0!==this.keyOf(t)}*indexEntries(t=!1){for(const e of this.entries(t))s(e[0])&&(yield e)}*indexKeys(){this._rio?.depend();for(const t of this._keys)s(t)&&(yield t)}isLocked(t){return this._rio?.depend(),void 0===t?this._locked:(t=this.#t(t),!(!this._locked||Object.hasOwn(this._storage,t))||!Object.getOwnPropertyDescriptor(this._storage,t)?.writable)}isRedacted(t){return this._rio?.depend(),!0===this._redacted||(t=this.#t(t),s(t)?this._redacted?.[0]:this._redacted?.[t])}keyOf(t){return this.find((e=>e===t))?.[0]}keys(){return this._rio?.depend(),this._keys.values()}lastKeyOf(t){return this.findLast((e=>e===t))?.[0]}lock(...t){"object"==typeof t[0]&&(key=t[0]);for(let e of t)e=this.#t(e),s(e)&&(this._lockInd=!0),void 0!==e&&Object.defineProperty(this._storage,e,{value:this.at(e),enumerable:!0,writable:!1,configurable:!1});return this._rio?.changed(),this}lockAll(t=!1){return t&&(this._lockNew=!0),this.lock(this._keys.values()),this}lockKeys(){return this._locked=!0,this._rio?.changed(),this}*namedEntries(){for(const t of this.entries())s(t[0])||(yield t)}*namedKeys(){for(const t of this.entries())s(t[0])||(yield t[0])}get next(){return this._rio?.depend(),this._next}set next(t){if(this._locked)throw new TypeError("NANOS: Cannot set next after locking");if(Number.isInteger(t)&&!(t<0)){for(let e=this._next;--e>=t;this.delete(e));this._next!==t&&(this._next=t,this._rio?.changed())}}pairs(t=!1){return[...this.entries(t)].flat(1)}pop(){if(this._locked)throw new TypeError("NANOS: Cannot pop after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot pop after index lock");if(this._next)return this.delete(--this._next)}push(...t){if(this._locked)throw new TypeError("NANOS: Cannot push after locking");return(this._rio?.batch||(t=>t()))((()=>t.forEach((t=>{const e=this._next;if(t instanceof i)for(const r of t.entries())s(r[0])?this.set(e+parseInt(r[0],10),r[1]):this.set(r[0],r[1]);else if("object"==typeof t)for(const r of Object.keys(t))s(r)?this.set(e+parseInt(r,10),t[r]):this.set(r,t[r]);else this.set(this._next,t)})))),this}redact(...t){for(const e of t){if(!0===e&&(this._redacted=!0),!0===this._redacted)return;this._redacted||={},s(e)?this._redacted[0]=!0:this._redacted[e]=!0}return this._rio?.changed(),this}#e(t,e,r){const i=(t,e)=>{Object.hasOwn(this._storage,t)&&(this._storage[t+e]=this._storage[t],delete this._storage[t])};if(r>0){e+r>this._next&&(this._next=e+r);for(let s=e;--s>=t;)i(s,r)}else if(r<0){e>=this._next&&(this._next+=r);for(let s=t;s<e;++s)i(s,r)}r&&(this._keys=this._keys.map((i=>{const n=s(i)&&parseInt(i,10);return!1!==n&&n>=t&&n<e?n+r+"":i})))}reverse(){if(this._locked)throw new TypeError("NANOS: Cannot reverse after locking");const t=this._storage,e=[],r={},i=this._next-1;for(const n of this._keys.toReversed()){const o=s(n)?i-n:n;r[o]=t[n],e.push(o)}return this._storage=r,this._keys=e,this._rio?.changed(),this}get rio(){return this._rio}set rio(t){t?t?.batch&&t.changed&&t.create&&t.depend&&(this._rio=t):delete this._rio}set(t,e,r=!1){if(this._locked)throw new TypeError("NANOS: Cannot set after locking");if(void 0===t&&(t=this._next),void 0===(t=this.#t(t)))return;const i=""+t,n=s(i)&&parseInt(i,10);let o=!1;if(!Object.hasOwn(this._storage,i)){if(o=!0,r)if(!1!==n&&this._next){let t=this._keys.length;for(;t>0&&(!s(this._keys[t-1])||n<this._keys[t-1]);)--t;this._keys.splice(t,0,i)}else this._keys.unshift(i);else if(!1===n||n>=this._next)this._keys.push(i);else{let t=0;for(;t<this._keys.length&&(!s(this._keys[t])||n>this._keys[t]);)++t;this._keys.splice(t,0,i)}!1!==n&&n>=this._next&&(this._next=n+1)}if("object"==typeof e&&this._autoPromote&&null!==e)switch(e?.constructor?.name){case void 0:case"Array":case"Object":this._storage[i]=this.similar(e);break;default:this._storage[i]=e}else this._storage[i]=e;return this._lockNew&&this.lock(i),o&&this._rio?.changed(),e}setAutoPromote(t){return this._autoPromote=t,this}setRIO(t){return this.rio=t,this}shift(){if(this._locked)throw new TypeError("NANOS: Cannot shift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot shift after index lock");if(!this._next)return;return(this._rio?.batch||(t=>t()))((()=>{const t=this.delete(0);return this.#e(1,this._next,-1),t}))}get size(){return this._rio?.depend(),this._keys.length}similar(...t){const e=new i;return this._autoPromote&&(e.autoPromote=!0),e.rio=this._rio?.create(),t.length&&e.push(...t),e}get storage(){return this._rio?.depend(),this._storage}toReversed(){return this._rio?.depend(),this.similar().fromPairs(this.toJSON()).reverse()}toJSON(){return this._rio?.depend(),{type:"@NANOS@",next:this._next,pairs:this.pairs(!0)}}toSLID({compact:e=!1,redact:r=!1}={}){this._rio?.depend();function n(e){switch(e){case!1:return"@f";case null:return"@n";case!0:return"@t";case void 0:return"@u"}switch(typeof e){case"bigint":return e.toString()+"n";case"number":return e.toString();case"string":return/^[!()*.,:;<>?A-Z{}_][!()*.,0-9:;<>?@A-Z{}_-]*$/i.test(e)?e:"'"+(t(e).replace(/\)]/g,")\\]")+"'")}return e instanceof i?"["+o(e)+"]":"@u/*??*/"}function o(t){let i=0;if(r&&!0===t._redacted)return"comment"===r?"/*???*/":"";const o=[];for(const e of t.entries())if(s(e[0])){if(r&&t.isRedacted(0)){"comment"===r&&o.push("/*?*/");continue}const s=parseInt(e[0],10);o.push((s===i?"":`${s}=`)+n(e[1])),i=s+1}else r&&t.isRedacted(e[0])?"comment"===r&&o.push("/*?=?*/"):o.push(n(e[0])+"="+n(e[1]));return e?function(t){const e=[];for(const s of t){const t=e.length?e.slice(-1).slice(-1):"",r=t+(s[0]||"");t&&!/['"\[\]]/.test(r)&&e.push(" "),e.push(s)}return e.join("")}(o):o.join(" ")}return"[("+o(this).replace(/\)\]/g,")\\]")+")]"}toString(t={}){return this.toSLID({redact:!0,...t})}unshift(...t){if(this._locked)throw new TypeError("NANOS: Cannot unshift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot unshift after index lock");return(this._rio?.batch||(t=>t()))((()=>t.toReversed().forEach((t=>{if(t instanceof i)this.#e(0,this._next,t.next),this.fromEntries(t.entries(),!0);else if("object"==typeof t){const e=Array.isArray(t)?t.length:Object.keys(t).filter((t=>s(t))).reduce(((t,e)=>Math.max(t,e)),-1)+1;this.#e(0,this._next,e),this.fromEntries(Object.entries(t),!0)}else this.unshift([t])})))),this}*values(){this._rio?.depend();for(let t=0;t<this._next;++t)yield this.at(t)}#t(t){if(!(r(t)&&(t=parseInt(t,10)+this._next)<0))return t}}i.prototype.get=i.prototype.at;const n={mlc:"/\\*.*?\\*/",num:"[+-]?(?:0[bBoOxX])?[0-9]+(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+|n)?(?![0-9a-zA-Z])",sqs:"'(?:\\\\'|[^'])*'",dqs:'"(?:\\\\"|[^"])*"',stok:"[[=\\]]",spc:"\\s+",oth:"[^'\"/[=\\]\\s]+"},o=new RegExp("("+"mlc num sqs dqs stok spc oth".split(" ").map((t=>n[t])).join("|")+")","s"),h=new RegExp("^"+n.num+"$");function a(t,s=!1){let r=t.match(/\[\((.*?)\)\]/s);if(!r)throw new SyntaxError("SLID boundary marker(s) not found");const n=r[1].replace(/\)\\\]/g,")]").split(o).filter((t=>!/^(\s*|\/\*.*\*\/)$/.test(t)));r=void 0;const a=()=>{const t=n.shift();return h.test(t)?/n$/i.test(t)?BigInt(t.slice(0,-1)):/^[+-]?0b/i.test(t)?parseInt(t.replace(/0b/i,""),2):/^[+-]?0o/i.test(t)?parseInt(t.replace(/0o/i,""),8):/^[+-]?0x/i.test(t)?parseInt(t.replace(/0x/i,""),16):parseFloat(t):"'"!==t[0]&&'"'!==t[0]?t:e(t.slice(1,-1))},c=()=>{if("["!==n[0]){if(!s)switch(n[0]){case"@f":return n.shift(),!1;case"@n":return n.shift(),null;case"@t":return n.shift(),!0;case"@u":return void n.shift()}return a()}return n.shift(),f()};function f(){const t=new i;for(;n.length&&"]"!==n[0];){let e;if("="===n[1])e=a(),n.shift();else if(!s&&"@e"===n[0]){n.shift(),++t.next;continue}t.set(e,c())}return"]"===n[0]&&n.shift(),t}const d=f();if(n.length)throw new SyntaxError("Malformed SLID");return d}const c={"{":"[","}":"]",",":" ",":":"="};function f(t){return a("[("+t.replaceAll(/^\s*[\[\{]?|[\]\}]\s*$/g,"").split(/("(?:\\\\"|[^"])*")/).map((t=>'"'===t[0]?t:t.replace(/[{},:]/g,(t=>c[t])))).join("")+")]",!0)}export{i as NANOS,i as default,s as isIndex,r as isNegIndex,f as parseQJSON,a as parseSLID};
//# sourceMappingURL=nanos.min.esm.js.map
