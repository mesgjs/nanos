import{escapeJSString as p,unescapeJSString as g}from"./vendor/escape-js.esm.js";const f=d=>/^(?:0|[1-9]\d*)$/.test(d),k=d=>/^-[1-9]\d*$/.test(d);class a{constructor(...t){this.clear(),this.push(...t)}at(t,e){return this._rio?.depend(),t=this.#t(t),Object.hasOwn(this._storage,t)?this._storage[t]:e}get autoPromote(){return this._autoPromote}set autoPromote(t){this._autoPromote=t}clear(){if(this._locked)throw new TypeError("NANOS: Cannot clear after locking");return this._next=0,this._keys=[],this._storage={},this._lockInd=void 0,delete this._redacted,this._rio?.changed(),this}delete(t){if(this._locked)throw new TypeError("NANOS: Cannot delete after locking");const e=""+t,s=this._storage[e];return Object.hasOwn(this._storage,e)&&(delete this._storage[e],this._keys=this._keys.filter(r=>r!==e),this._rio?.changed()),s}depend(){this._rio?.depend()}*entries(t=!1){this._rio?.depend();const e=t?s=>f(s)?parseInt(s,10):s:s=>s;for(const s of this._keys)yield[e(s),this._storage[s]]}filter(t){return this._rio?.depend(),new a.fromEntries([...this.entries()].filter(e=>t(e[1],e[0],this)))}find(t){this._rio?.depend();const e=this._storage;for(const s of this._keys)if(t(e[s],s,this))return[s,e[s]]}findLast(t){this._rio?.depend();const e=this._storage;for(const s of this._keys.toReversed())if(t(e[s],s,this))return[s,e[s]]}forEach(t){this._rio?.depend();for(const e of this._keys)t(this._storage[e],e,this)}fromEntries(t,e=!1){if(this._locked)throw new TypeError("NANOS: Cannot fromEntries after locking");if(e&&this._lockInd)throw new TypeError("NANOS: Cannot insert fromEntries after index lock");return(this._rio?.batch||(r=>r()))(()=>{if(e)for(const r of[...t].reverse())this.set(r[0],r[1],!0);else for(const r of t)this.set(r[0],r[1]);this._rio?.changed()}),this}fromPairs(...t){if(this._locked)throw new TypeError("NANOS: Cannot fromPairs after locking");const e=this._rio?.batch||(r=>r());if(t[0]?.type==="@NANOS@")return e(()=>{this.fromPairs(t[0].pairs),this.next=t[0].next,this._rio?.changed()}),this;Array.isArray(t[0])&&(t=t[0]);const s=t.length-1;return e(()=>{for(let r=0;r<s;r+=2)t[r]===void 0&&!(r+1 in t)?++this._next:this.set(t[r],t[r+1]);this._rio?.changed()}),this}has(t){return this._rio?.depend(),Object.hasOwn(this._storage,this.#t(t))}includes(t){return this.keyOf(t)!==void 0}*indexEntries(t=!1){for(const e of this.entries(t))f(e[0])&&(yield e)}*indexKeys(){this._rio?.depend();for(const t of this._keys)f(t)&&(yield t)}isLocked(t){return this._rio?.depend(),t===void 0?this._locked:(t=this.#t(t),this._locked&&!Object.hasOwn(this._storage,t)?!0:!Object.getOwnPropertyDescriptor(this._storage,t)?.writable)}isRedacted(t){return this._rio?.depend(),this._redacted===!0?!0:(t=this.#t(t),f(t)?this._redacted?.[0]:this._redacted?.[t])}keyOf(t){return this.find(e=>e===t)?.[0]}keys(){return this._rio?.depend(),this._keys.values()}lastKeyOf(t){return this.findLast(e=>e===t)?.[0]}lock(...t){typeof t[0]=="object"&&(key=t[0]);for(let e of t)e=this.#t(e),f(e)&&(this._lockInd=!0),e!==void 0&&Object.defineProperty(this._storage,e,{value:this.at(e),enumerable:!0,writable:!1,configurable:!1});return this._rio?.changed(),this}lockAll(t=!1){return t&&(this._lockNew=!0),this.lock(this._keys.values()),this}lockKeys(){return this._locked=!0,this._rio?.changed(),this}*namedEntries(){for(const t of this.entries())f(t[0])||(yield t)}*namedKeys(){for(const t of this.entries())f(t[0])||(yield t[0])}get next(){return this._rio?.depend(),this._next}set next(t){if(this._locked)throw new TypeError("NANOS: Cannot set next after locking");if(!(!Number.isInteger(t)||t<0)){for(let e=this._next;--e>=t;this.delete(e));this._next!==t&&(this._next=t,this._rio?.changed())}}pairs(t=!1){return[...this.entries(t)].flat(1)}pop(){if(this._locked)throw new TypeError("NANOS: Cannot pop after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot pop after index lock");if(this._next)return this.delete(--this._next)}push(...t){if(this._locked)throw new TypeError("NANOS: Cannot push after locking");return(this._rio?.batch||(s=>s()))(()=>t.forEach(s=>{const r=this._next;if(s instanceof a||s instanceof Map)for(const i of s.entries())f(i[0])?this.set(r+parseInt(i[0],10),i[1]):this.set(i[0],i[1]);else if(s instanceof Set)this.push(...s);else if(typeof s=="object")for(const i of Object.keys(s))f(i)?this.set(r+parseInt(i,10),s[i]):this.set(i,s[i]);else this.set(this._next,s)})),this}redact(...t){for(const e of t){if(e===!0&&(this._redacted=!0),this._redacted===!0)return;this._redacted||={},f(e)?this._redacted[0]=!0:this._redacted[e]=!0}return this._rio?.changed(),this}#e(t,e,s){const r=(i,h)=>{Object.hasOwn(this._storage,i)&&(this._storage[i+h]=this._storage[i],delete this._storage[i])};if(s>0){e+s>this._next&&(this._next=e+s);for(let i=e;--i>=t;)r(i,s)}else if(s<0){e>=this._next&&(this._next+=s);for(let i=t;i<e;++i)r(i,s)}s&&(this._keys=this._keys.map(i=>{const h=f(i)&&parseInt(i,10);return h!==!1&&h>=t&&h<e?h+s+"":i}))}reverse(){if(this._locked)throw new TypeError("NANOS: Cannot reverse after locking");const t=this._storage,e=[],s={},r=this._next-1;for(const i of this._keys.toReversed()){const h=f(i)?r-i:i;s[h]=t[i],e.push(h)}return this._storage=s,this._keys=e,this._rio?.changed(),this}get rio(){return this._rio}set rio(t){t?t?.batch&&t.changed&&t.create&&t.depend&&(this._rio=t):delete this._rio}set(t,e,s=!1){if(this._locked)throw new TypeError("NANOS: Cannot set after locking");if(t===void 0&&(t=this._next),t=this.#t(t),t===void 0)return;const r=""+t,i=f(r)&&parseInt(r,10);let h=!1;if(!Object.hasOwn(this._storage,r)){if(h=!0,s)if(i===!1||!this._next)this._keys.unshift(r);else{let n=this._keys.length;for(;n>0&&(!f(this._keys[n-1])||i<this._keys[n-1]);)--n;this._keys.splice(n,0,r)}else if(i===!1||i>=this._next)this._keys.push(r);else{let n=0;for(;n<this._keys.length&&(!f(this._keys[n])||i>this._keys[n]);)++n;this._keys.splice(n,0,r)}i!==!1&&i>=this._next&&(this._next=i+1)}if(typeof e=="object"&&this._autoPromote&&e!==null)switch(e?.constructor?.name){case void 0:case"Array":case"Object":this._storage[r]=this.similar(e);break;default:this._storage[r]=e;break}else this._storage[r]=e;return this._lockNew&&this.lock(r),h&&this._rio?.changed(),e}setAutoPromote(t){return this._autoPromote=t,this}setRIO(t){return this.rio=t,this}shift(){if(this._locked)throw new TypeError("NANOS: Cannot shift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot shift after index lock");return this._next?(this._rio?.batch||(e=>e()))(()=>{const e=this.delete(0);return this.#e(1,this._next,-1),e}):void 0}get size(){return this._rio?.depend(),this._keys.length}similar(...t){const e=new a;return this._autoPromote&&(e.autoPromote=!0),e.rio=this._rio?.create(),t.length&&e.push(...t),e}get storage(){return this._rio?.depend(),this._storage}toReversed(){return this._rio?.depend(),this.similar().fromPairs(this.toJSON()).reverse()}toJSON(){return this._rio?.depend(),{type:"@NANOS@",next:this._next,pairs:this.pairs(!0)}}toSLID({compact:t=!1,redact:e=!1}={}){this._rio?.depend();const s=n=>p(n).replace(/\)]/g,")\\]");function r(n){const o=[];for(const c of n){const l=o.length?o.slice(-1).slice(-1):"",_=l+(c[0]||"");l&&!/['"\[\]]/.test(_)&&o.push(" "),o.push(c)}return o.join("")}function i(n){switch(n){case!1:return"@f";case null:return"@n";case!0:return"@t";case void 0:return"@u"}switch(typeof n){case"bigint":return n.toString()+"n";case"number":return n.toString();case"string":return/^[!()*.,:;<>?A-Z{}_][!()*.,0-9:;<>?@A-Z{}_-]*$/i.test(n)?n:"'"+s(n)+"'"}return n instanceof a?"["+h(n)+"]":"@u/*??*/"}function h(n){let o=0;if(e&&n._redacted===!0)return e==="comment"?"/*???*/":"";const c=[];for(const l of n.entries())if(f(l[0])){if(e&&n.isRedacted(0)){e==="comment"&&c.push("/*?*/");continue}const _=parseInt(l[0],10);c.push((_===o?"":`${_}=`)+i(l[1])),o=_+1}else e&&n.isRedacted(l[0])?e==="comment"&&c.push("/*?=?*/"):c.push(i(l[0])+"="+i(l[1]));return t?r(c):c.join(" ")}return"[("+h(this).replace(/\)\]/g,")\\]")+")]"}toString(t={}){return this.toSLID({redact:!0,...t})}unshift(...t){if(this._locked)throw new TypeError("NANOS: Cannot unshift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot unshift after index lock");return(this._rio?.batch||(s=>s()))(()=>t.toReversed().forEach(s=>{if(s instanceof a)this.#e(0,this._next,s.next),this.fromEntries(s.entries(),!0);else if(s instanceof Map){const r=Array.from(s.keys()).filter(i=>f(i)).reduce((i,h)=>Math.max(i,h),-1)+1;this.#e(0,this._next,r),this.fromEntries(s.entries(),!0)}else if(s instanceof Set)this.unshift(...s);else if(typeof s=="object"){const r=Array.isArray(s)?s.length:Object.keys(s).filter(i=>f(i)).reduce((i,h)=>Math.max(i,h),-1)+1;this.#e(0,this._next,r),this.fromEntries(Object.entries(s),!0)}else this.unshift([s])})),this}*values(){this._rio?.depend();for(let t=0;t<this._next;++t)yield this.at(t)}#t(t){if(!(k(t)&&(t=parseInt(t,10)+this._next,t<0)))return t}}a.prototype.get=a.prototype.at;const u={mlc:"/\\*.*?\\*/",flt:"[+-]?\\d+(?:[.]\\d+)?(?:[eE][+-]?\\d+)?(?![0-9a-zA-Z])",int:"[+-]?(?:0[bB][01]+|0[oO][0-7]+|0[xX][0-9a-fA-F]+|\\d+)n?(?![0-9a-zA-Z])",sqs:"'(?:\\\\'|[^'])*'",dqs:'"(?:\\\\"|[^"])*"',stok:"[[=\\]]",spc:"\\s+",oth:`(?:[^'"/[=\\]\\s]|\\/(?![*]))+`},x=new RegExp("("+"mlc flt int sqs dqs stok spc oth".split(" ").map(d=>u[d]).join("|")+")","s"),w=new RegExp(`^(${u.flt}|${u.int})$`);function m(d,t=!1){let e=d.match(/\[\((.*?)\)\]/s);if(!e)throw new SyntaxError("Missing SLID boundary marker(s)");const s=e[1].replace(/\)\\\]/g,")]").split(x).filter(o=>!/^(\s*|\/\*.*\*\/)$/.test(o));e=void 0;const r=()=>{const o=s.shift();if(w.test(o))return/n$/i.test(o)?BigInt(o.slice(0,-1)):/^[+-]?0b/i.test(o)?parseInt(o.replace(/0b/i,""),2):/^[+-]?0o/i.test(o)?parseInt(o.replace(/0o/i,""),8):/^[+-]?0x/i.test(o)?parseInt(o.replace(/0x/i,""),16):parseFloat(o);if(o==="'"||o==='"')throw new SyntaxError(`Unmatched ${o} in SLID`);return o[0]!=="'"&&o[0]!=='"'?o:g(o.slice(1,-1))},i=()=>{if(s[0]!=="["){if(!t)switch(s[0]){case"@f":return s.shift(),!1;case"@n":return s.shift(),null;case"@t":return s.shift(),!0;case"@u":s.shift();return}return r()}return s.shift(),h()};function h(){const o=new a;for(;s.length&&s[0]!=="]";){let c;if(s[1]==="=")c=r(),s.shift();else if(!t&&s[0]==="@e"){s.shift(),++o.next;continue}o.set(c,i())}return s[0]==="]"&&s.shift(),o}const n=h();if(s.length)throw new SyntaxError("Malformed SLID");return n}const y={"{":"[","}":"]",",":" ",":":"="};function b(d){return m("[("+d.replaceAll(/^\s*[\[\{]?|[\]\}]\s*$/g,"").split(/("(?:\\\\"|[^"])*")/).map(t=>t[0]==='"'?t:t.replace(/[{},:]/g,e=>y[e])).join("")+")]",!0)}export{a as NANOS,a as default,f as isIndex,k as isNegIndex,b as parseQJSON,m as parseSLID};
