import{escapeJSString as y,unescapeJSString as m}from"./vendor/escape-js.esm.js";const w={mlc:"/\\*.*?\\*/",flt:"[+-]?\\d+(?:[.]\\d+)?(?:[eE][+-]?\\d+)?(?![0-9a-zA-Z])",int:"[+-]?(?:0[bB][01]+|0[oO][0-7]+|0[xX][0-9a-fA-F]+|\\d+)n?(?![0-9a-zA-Z])",sqs:"'(?:\\\\'|[^'])*'",dqs:'"(?:\\\\"|[^"])*"',stok:"[[=\\]]",spc:"\\s+",oth:`(?:[^'"/[=\\]\\s]|\\/(?![*]))+`},O=new RegExp("("+"mlc flt int sqs dqs stok spc oth".split(" ").map(_=>w[_]).join("|")+")","s"),S=new RegExp(`^(${w.flt}|${w.int})$`),b={"{":"[","}":"]",",":" ",":":"="},a=_=>/^(?:0|[1-9]\d*)$/.test(_),I=_=>/^-[1-9]\d*$/.test(_),p=_=>{if(typeof _!="object"||_===null)return!1;const t=_?.constructor?.name;return t===void 0||t==="Object"};class c{constructor(...t){this._options={},this.clear(),this.push(...t)}at(t,e={}){if(e=this.#e(e,"default"),Array.isArray(t)){let s=this;for(const r of t){if(s=this.#t(s),!(s instanceof c)||!s.has(r))return e.default;s=s.atRaw(r)}return!e.raw&&this._rio?.get&&(s=this.#t(s)),s}if(this._rio?.depend(),t=this.#s(t),Object.hasOwn(this._storage,t)){let s=this._storage[t];return!e.raw&&this._rio?.get&&(s=this.#t(s)),s}return e.default}atRaw(t,e={}){return e=this.#e(e,"default",{raw:!0}),this.at(t,e)}clear(){if(this._locked)throw new TypeError('NANOS: Cannot "clear" after locking');return this._next=0,this._keys=[],this._storage={},this._lockInd=void 0,delete this._redacted,this._rio?.changed(),this}deepFreeze(){this.freeze();for(const[t,e]of this.entries())e instanceof c&&e.deepFreeze();return this}delete(t,e={}){if(this._locked)throw new TypeError('NANOS: Cannot "delete" after locking');const s=String(t),r=this._storage[s];return Object.hasOwn(this._storage,s)&&(delete this._storage[s],this._keys=this._keys.filter(i=>i!==s),this._rio?.changed()),e.raw?r:this.#t(r)}depend(){this._rio?.depend()}*entries(t={}){t=this.#e(t,"compact"),this._rio?.depend();const e=this._storage,s=t.compact?i=>a(i)?parseInt(i,10):i:i=>i,r=t.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys)yield[s(i),r(e[i])]}filter(t,e={}){this._rio?.depend();const s=this.similar();return s.fromEntries([...this.entries(e)].filter(r=>t(r[1],r[0],this))),s}#t(t){for(;this._rio?.isReactive?.(t);)t=this._rio.get(t);return t}find(t,e={}){this._rio?.depend();const s=this._storage,r=e.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys){const h=r(s[i]);if(t(h,i,this))return[i,h]}}findLast(t,e={}){this._rio?.depend();const s=this._storage,r=e.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys.toReversed()){const h=r(s[i]);if(t(h,i,this))return[i,h]}}forEach(t,e={}){this._rio?.depend();const s=this._storage,r=e.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys){const h=r(s[i]);t(h,i,this)}}freeze(){return Object.isFrozen(this)||(this._locked=!0,this._lockInd=!0,Object.freeze(this)),Object.freeze(this._keys),Object.freeze(this._storage),typeof this._redacted=="object"&&Object.freeze(this._redacted),this}from(t,e={}){if(this._locked)throw new TypeError('NANOS: Cannot "from" after locking');return t instanceof c?((this._rio?.batch||(r=>r()))(()=>{for(const r of t.entries({raw:e.raw})){let[i,h]=r;e.deep&&h instanceof c&&(h=this.similar().from(h,e)),this.set(i,h,{raw:!0})}this.next=t.next}),this):this}fromEntries(t,e=!1){if(this._locked)throw new TypeError('NANOS: Cannot "fromEntries" after locking');if(e&&this._lockInd)throw new TypeError('NANOS: Cannot insert "fromEntries" after index lock');return(this._rio?.batch||(r=>r()))(()=>{if(e)for(const r of[...t].reverse())this.set(r[0],r[1],!0);else for(const r of t)this.set(r[0],r[1]);this._rio?.changed()}),this}fromPairs(...t){if(this._locked)throw new TypeError('NANOS: Cannot "fromPairs" after locking');const e=this._rio?.batch||(r=>r());if(p(t[0])&&t[0].type==="@NANOS@")return e(()=>{this.fromPairs(t[0].pairs),this.next=t[0].next,this._rio?.changed()}),this;Array.isArray(t[0])&&(t=t[0]);const s=t.length-1;return e(()=>{for(let r=0;r<s;r+=2)t[r]===void 0&&!(r+1 in t)?++this._next:this.set(t[r],t[r+1]);this._rio?.changed()}),this}#e(t,e,s={}){const r=p(t)?t:{[e]:t};return{...s,...r}}has(t){return this._rio?.depend(),Object.hasOwn(this._storage,this.#s(t))}includes(t,e={}){return this.keyOf(t,e)!==void 0}*indexEntries(t){t=this.#e(t,"compact");for(const e of this.entries(t))a(e[0])&&(yield e)}*indexKeys(){this._rio?.depend();for(const t of this._keys)a(t)&&(yield t)}isLocked(t){return this._rio?.depend(),t===void 0?!!this._locked:(t=this.#s(t),this._locked&&!Object.hasOwn(this._storage,t)?!0:!Object.getOwnPropertyDescriptor(this._storage,t)?.writable)}isRedacted(t){return this._rio?.depend(),this._redacted===!0?!0:(t=this.#s(t),a(t)?!!this._redacted?.[0]:!!this._redacted?.[t])}keyOf(t,e={}){return this.find(s=>s===t,e)?.[0]}keys(){return this._rio?.depend(),this._keys.values()}lastKeyOf(t,e={}){return this.findLast(s=>s===t,e)?.[0]}lock(...t){t.length===1&&Array.isArray(t[0])&&(t=t[0]);for(let e of t)e=this.#s(e),a(e)&&(this._lockInd=!0),e!==void 0&&Object.defineProperty(this._storage,e,{value:this.at(e),enumerable:!0,writable:!1,configurable:!1});return this._rio?.changed(),this}lockAll(t=!1){return t&&(this._lockNew=!0),this.lock(this._keys),this}lockKeys(){return this._locked=!0,this._rio?.changed(),this}#i(t){return p(t)||!this._options.opaqueMaps&&t instanceof Map}*namedEntries(t={}){for(const e of this.entries(t))a(e[0])||(yield e)}*namedKeys(t={}){for(const e of this.entries({...t,raw:!0}))a(e[0])||(yield e[0])}get next(){return this._rio?.depend(),this._next}set next(t){if(this._locked)throw new TypeError('NANOS: Cannot set "next" after locking');if(!(!Number.isInteger(t)||t<0)){for(let e=this._next;--e>=t;this.delete(e));this._next!==t&&(this._next=t,this._rio?.changed())}}get options(){return Object.assign({},this._options)}pairs(t={}){return t=this.#e(t,"compact"),[...this.entries(t)].flat(1)}static parseQJSON(t){return E("[("+t.replaceAll(/^\s*[\[\{]?|[\]\}]\s*$/g,"").split(/("(?:\\\\"|[^"])*")/).map(e=>e[0]==='"'?e:e.replace(/[{},:]/g,s=>b[s])).join("")+")]",!0)}static parseSLID(t,e=!1){let s=t.match(/\[\((.*?)\)\]/s);if(!s)throw new SyntaxError("Missing SLID boundary marker(s)");const r=s[1].replace(/\)\\\]/g,")]").split(O).filter(n=>!/^(\s*|\/\*.*\*\/)$/.test(n));s=void 0;const i=()=>{const n=r.shift();if(S.test(n))return/n$/i.test(n)?BigInt(n.slice(0,-1)):/^[+-]?0b/i.test(n)?parseInt(n.replace(/0b/i,""),2):/^[+-]?0o/i.test(n)?parseInt(n.replace(/0o/i,""),8):/^[+-]?0x/i.test(n)?parseInt(n.replace(/0x/i,""),16):parseFloat(n);if(n==="'"||n==='"')throw new SyntaxError(`Unmatched ${n} in SLID`);return n[0]!=="'"&&n[0]!=='"'?n:m(n.slice(1,-1))},h=()=>{if(r[0]!=="["){if(e)switch(r[0]){case"false":return r.shift(),!1;case"null":return r.shift(),null;case"true":return r.shift(),!0}else switch(r[0]){case"@f":return r.shift(),!1;case"@n":return r.shift(),null;case"@t":return r.shift(),!0;case"@u":r.shift();return}return i()}return r.shift(),o.call(this)},o=()=>{const n=new c;for(;r.length&&r[0]!=="]";){let f;if(r[1]==="=")f=i(),r.shift();else if(!e&&r[0]==="@e"){r.shift(),++n.next;continue}n.set(f,h())}return r[0]==="]"&&r.shift(),n},l=o();if(r.length)throw new SyntaxError("Malformed SLID");return l}pop(t={}){if(this._locked)throw new TypeError('NANOS: Cannot "pop" after locking');if(this._lockInd)throw new TypeError('NANOS: Cannot "pop" after index lock');if(this._next)return this.delete(--this._next,t)}push(...t){if(this._locked)throw new TypeError('NANOS: Cannot "push" after locking');const e=this._rio?.batch||(n=>n()),s=this._options,r=s.transform,i=(n,f=0)=>{const d=this._next,k=d+f;for(let[g,u]of n)if(a(g)){const x=d+parseInt(g,10);r&&(this.#i(u)||this.#r(u))&&(u=this.similar(u)),this.set(x,u)}else this.set(g,u);this._next<k&&(this._next=k)},h=n=>{for(let[f,d]of n)a(f)?this.#i(d)?h(this.similar(d).entries()):(this.#r(d)&&(d=this.similar(d)),this.set(void 0,d)):this.set(f,d)},o=r==="sets"?h:i,l=n=>{p(n)?o(Object.entries(n)):Array.isArray(n)?o(Object.entries(n),n.length):n instanceof c?o(n.entries(),n.next):!s.opaqueMaps&&n instanceof Map?o(n.entries()):!s.opaqueSets&&n instanceof Set?o([...n.values()].entries()):this.set(void 0,n)};return e(()=>t.forEach(l)),this}redact(...t){for(const e of t){if(e===!0&&(this._redacted=!0),this._redacted===!0)return;this._redacted||={},a(e)?this._redacted[0]=!0:this._redacted[e]=!0}return this._rio?.changed(),this}#n(t,e,s){const r=(i,h)=>{Object.hasOwn(this._storage,i)&&(this._storage[i+h]=this._storage[i],delete this._storage[i])};if(s>0){e+s>this._next&&(this._next=e+s);for(let i=e;--i>=t;)r(i,s)}else if(s<0){e>=this._next&&(this._next+=s);for(let i=t;i<e;++i)r(i,s)}s&&(this._keys=this._keys.map(i=>{const h=a(i)&&parseInt(i,10);return h!==!1&&h>=t&&h<e?h+s+"":i}))}reverse(){if(this._locked)throw new TypeError('NANOS: Cannot "reverse" after locking');const t=this._storage,e=[],s={},r=this._next-1;for(const i of this._keys.toReversed()){const h=a(i)?String(r-parseInt(i,10)):i;s[h]=t[i],e.push(h)}return this._storage=s,this._keys=e,this._rio?.changed(),this}*reverseEntries(t={}){t=this.#e(t,"compact"),this._rio?.depend();const e=this._storage,s=t.compact?i=>a(i)?parseInt(i,10):i:i=>i,r=t.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys.toReversed())yield[s(i),r(e[i])]}get rio(){return this._rio}set rio(t){t?t?.batch&&t.changed&&t.create&&t.depend&&(this._rio=t):delete this._rio}set(t,e,s={}){if(s=this.#e(s,"insert"),this._locked)throw new TypeError('NANOS: Cannot "set" after locking');if(t===void 0&&(t=this._next),t=this.#s(t),t===void 0)return;const r=String(t),i=a(r)&&parseInt(r,10);let h=!1;if(!Object.hasOwn(this._storage,r)){if(h=!0,s.insert)if(i===!1||!this._next)this._keys.unshift(r);else{let o=this._keys.length;for(;o>0&&(!a(this._keys[o-1])||i<this._keys[o-1]);)--o;this._keys.splice(o,0,r)}else if(i===!1||i>=this._next)this._keys.push(r);else{let o=0;for(;o<this._keys.length&&(!a(this._keys[o])||i>this._keys[o]);)++o;this._keys.splice(o,0,r)}i!==!1&&i>=this._next&&(this._next=i+1)}return!s.raw&&this._rio?.onSet&&(e=this._rio.onSet(this,t,e)),this._options.transform&&(this.#r(e)||this.#i(e))?this._storage[r]=this.similar(e):this._storage[r]=e,this._lockNew&&this.lock(r),h&&this._rio?.changed(),e}setRaw(t,e,s={}){return s=this.#e(s,"insert",{raw:!0}),this.set(t,e,s)}#r(t){return Array.isArray(t)||!this._options.opaqueSets&&t instanceof Set}setOpts(t){return Object.assign(this._options,t),this}setRIO(t){return this.rio=t,this}shift(t={}){if(this._locked)throw new TypeError('NANOS: Cannot "shift" after locking');if(this._lockInd)throw new TypeError('NANOS: Cannot "shift" after index lock');return this._next?(this._rio?.batch||(s=>s()))(()=>{const s=this.delete(0,t);return this.#n(1,this._next,-1),s}):void 0}get size(){return this._rio?.depend(),this._keys.length}similar(...t){const e=new this.constructor;return e.setOptions(this._options),e.rio=this._rio?.create(),t.length&&e.push(...t),e}get storage(){return this._rio?.depend(),this._storage}toReversed(){return this._rio?.depend(),this.similar().from(this).reverse()}toJSON(){return this._rio?.depend(),{type:"@NANOS@",next:this._next,pairs:this.pairs(!0)}}toSLID({compact:t=!1,redact:e=!1}={}){this._rio?.depend();const s=o=>y(o).replace(/\)]/g,")\\]"),r=o=>{const l=[];for(const n of o){const f=l.length?l.slice(-1).slice(-1):"",d=f+(n[0]||"");f&&!/['"\[\]]/.test(d)&&l.push(" "),l.push(n)}return l.join("")},i=o=>{switch(o){case!1:return"@f";case null:return"@n";case!0:return"@t";case void 0:return"@u"}switch(typeof o){case"bigint":return o.toString()+"n";case"number":return o.toString();case"string":return/^[~!#$%^&*()+.,:;<>?A-Z{}_][~!@#$%^&*()+.,0-9:;<>?A-Z{}_-]*$/i.test(o)?o:"'"+s(o)+"'"}return(p(o)||Array.isArray(o)||o instanceof Map||o instanceof Set)&&(o=new this.constructor(o)),o instanceof c?"["+h(o)+"]":"@u/*??*/"},h=o=>{let l=0;if(e&&o._redacted===!0)return e==="comment"?"/*???*/":"";const n=[];for(const f of o.entries())if(a(f[0])){if(e&&o.isRedacted(0)){e==="comment"&&n.push("/*?*/");continue}const d=parseInt(f[0],10);n.push((d===l?"":`${d}=`)+i(f[1])),l=d+1}else e&&o.isRedacted(f[0])?e==="comment"&&n.push("/*?=?*/"):n.push(i(f[0])+"="+i(f[1]));return t?r(n):n.join(" ")};return"[("+h(this).replace(/\)\]/g,")\\]")+")]"}static toSLID(t,e={}){return t instanceof c?t.toSLID(e):new c(t).toSLID(e)}toString(t={}){return this.toSLID({redact:!0,...t})}unshift(...t){if(this._locked)throw new TypeError('NANOS: Cannot "unshift" after locking');if(this._lockInd)throw new TypeError('NANOS: Cannot "unshift" after index lock');return(this._rio?.batch||(s=>s()))(()=>t.toReversed().forEach(s=>{s instanceof c||(s=this.similar(s)),this.#n(0,this._next,s.next),this.fromEntries(s.entries(),!0)})),this}*values(t={}){this._rio?.depend();const e=t.raw||!this._rio?.get?s=>s:s=>this.#t(s);for(const s of this.indexKeys())yield e(this.atRaw(s))}#s(t){if(!(I(t)&&(t=parseInt(t,10)+this._next,t<0)))return t}}c.prototype.get=c.prototype.at,c.prototype.setOptions=c.prototype.setOpts;const{parseQJSON:N,parseSLID:E,toSLID:j}=c;export{c as NANOS,c as default,a as isIndex,I as isNegIndex,N as parseQJSON,E as parseSLID,j as toSLID};
