import{escapeJSString as y,unescapeJSString as m}from"./vendor/escape-js.esm.js";const w={mlc:"/\\*.*?\\*/",flt:"[+-]?\\d+(?:[.]\\d+)?(?:[eE][+-]?\\d+)?(?![0-9a-zA-Z])",int:"[+-]?(?:0[bB][01]+|0[oO][0-7]+|0[xX][0-9a-fA-F]+|\\d+)n?(?![0-9a-zA-Z])",sqs:"'(?:\\\\'|[^'])*'",dqs:'"(?:\\\\"|[^"])*"',stok:"[[=\\]]",spc:"\\s+",oth:`(?:[^'"/[=\\]\\s]|\\/(?![*]))+`},O=new RegExp("("+"mlc flt int sqs dqs stok spc oth".split(" ").map(l=>w[l]).join("|")+")","s"),S=new RegExp(`^(${w.flt}|${w.int})$`),b={"{":"[","}":"]",",":" ",":":"="},c=l=>/^(?:0|[1-9]\d*)$/.test(l),I=l=>/^-[1-9]\d*$/.test(l),p=l=>{if(typeof l!="object"||l===null)return!1;const t=l?.constructor?.name;return t===void 0||t==="Object"};class d{constructor(...t){this._options={},this.clear(),this.push(...t)}at(t,e={}){if(e=this.#e(e,"default"),Array.isArray(t)){let s=this;for(const r of t){if(s=this.#t(s),!(s instanceof d)||!s.has(r))return e.default;s=s.atRaw(r)}return!e.raw&&this._rio?.get&&(s=this.#t(s)),s}if(this._rio?.depend(),t=this.#s(t),Object.hasOwn(this._storage,t)){let s=this._storage[t];return!e.raw&&this._rio?.get&&(s=this.#t(s)),s}return e.default}atRaw(t,e={}){return e=this.#e(e,"default",{raw:!0}),this.at(t,e)}clear(){if(this._locked)throw new TypeError("NANOS: Cannot clear after locking");return this._next=0,this._keys=[],this._storage={},this._lockInd=void 0,delete this._redacted,this._rio?.changed(),this}deepFreeze(){this.freeze();for(const[t,e]of this.entries())e instanceof d&&e.deepFreeze();return this}delete(t,e={}){if(this._locked)throw new TypeError("NANOS: Cannot delete after locking");const s=String(t),r=this._storage[s];return Object.hasOwn(this._storage,s)&&(delete this._storage[s],this._keys=this._keys.filter(i=>i!==s),this._rio?.changed()),e.raw?r:this.#t(r)}depend(){this._rio?.depend()}*entries(t={}){t=this.#e(t,"compact"),this._rio?.depend();const e=this._storage,s=t.compact?i=>c(i)?parseInt(i,10):i:i=>i,r=t.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys)yield[s(i),r(e[i])]}filter(t,e={}){this._rio?.depend();const s=this.similar();return s.fromEntries([...this.entries(e)].filter(r=>t(r[1],r[0],this))),s}#t(t){for(;this._rio?.isReactive?.(t);)t=this._rio.get(t);return t}find(t,e={}){this._rio?.depend();const s=this._storage,r=e.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys){const h=r(s[i]);if(t(h,i,this))return[i,h]}}findLast(t,e={}){this._rio?.depend();const s=this._storage,r=e.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys.toReversed()){const h=r(s[i]);if(t(h,i,this))return[i,h]}}forEach(t,e={}){this._rio?.depend();const s=this._storage,r=e.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys){const h=r(s[i]);t(h,i,this)}}freeze(){return Object.isFrozen(this)||(this._locked=!0,this._lockInd=!0,Object.freeze(this)),Object.freeze(this._keys),Object.freeze(this._storage),typeof this._redacted=="object"&&Object.freeze(this._redacted),this}fromEntries(t,e=!1){if(this._locked)throw new TypeError("NANOS: Cannot fromEntries after locking");if(e&&this._lockInd)throw new TypeError("NANOS: Cannot insert fromEntries after index lock");return(this._rio?.batch||(r=>r()))(()=>{if(e)for(const r of[...t].reverse())this.set(r[0],r[1],!0);else for(const r of t)this.set(r[0],r[1]);this._rio?.changed()}),this}fromPairs(...t){if(this._locked)throw new TypeError("NANOS: Cannot fromPairs after locking");const e=this._rio?.batch||(r=>r());if(p(t[0])&&t[0].type==="@NANOS@")return e(()=>{this.fromPairs(t[0].pairs),this.next=t[0].next,this._rio?.changed()}),this;Array.isArray(t[0])&&(t=t[0]);const s=t.length-1;return e(()=>{for(let r=0;r<s;r+=2)t[r]===void 0&&!(r+1 in t)?++this._next:this.set(t[r],t[r+1]);this._rio?.changed()}),this}#e(t,e,s={}){const r=p(t)?t:{[e]:t};return{...s,...r}}has(t){return this._rio?.depend(),Object.hasOwn(this._storage,this.#s(t))}includes(t,e={}){return this.keyOf(t,e)!==void 0}*indexEntries(t){t=this.#e(t,"compact");for(const e of this.entries(t))c(e[0])&&(yield e)}*indexKeys(){this._rio?.depend();for(const t of this._keys)c(t)&&(yield t)}isLocked(t){return this._rio?.depend(),t===void 0?!!this._locked:(t=this.#s(t),this._locked&&!Object.hasOwn(this._storage,t)?!0:!Object.getOwnPropertyDescriptor(this._storage,t)?.writable)}isRedacted(t){return this._rio?.depend(),this._redacted===!0?!0:(t=this.#s(t),c(t)?!!this._redacted?.[0]:!!this._redacted?.[t])}keyOf(t,e={}){return this.find(s=>s===t,e)?.[0]}keys(){return this._rio?.depend(),this._keys.values()}lastKeyOf(t,e={}){return this.findLast(s=>s===t,e)?.[0]}lock(...t){t.length===1&&Array.isArray(t[0])&&(t=t[0]);for(let e of t)e=this.#s(e),c(e)&&(this._lockInd=!0),e!==void 0&&Object.defineProperty(this._storage,e,{value:this.at(e),enumerable:!0,writable:!1,configurable:!1});return this._rio?.changed(),this}lockAll(t=!1){return t&&(this._lockNew=!0),this.lock(this._keys),this}lockKeys(){return this._locked=!0,this._rio?.changed(),this}#i(t){return p(t)||!this._options.opaqueMaps&&t instanceof Map}*namedEntries(t={}){for(const e of this.entries(t))c(e[0])||(yield e)}*namedKeys(t={}){for(const e of this.entries({...t,raw:!0}))c(e[0])||(yield e[0])}get next(){return this._rio?.depend(),this._next}set next(t){if(this._locked)throw new TypeError("NANOS: Cannot set next after locking");if(!(!Number.isInteger(t)||t<0)){for(let e=this._next;--e>=t;this.delete(e));this._next!==t&&(this._next=t,this._rio?.changed())}}get options(){return Object.assign({},this._options)}pairs(t={}){return t=this.#e(t,"compact"),[...this.entries(t)].flat(1)}static parseQJSON(t){return N("[("+t.replaceAll(/^\s*[\[\{]?|[\]\}]\s*$/g,"").split(/("(?:\\\\"|[^"])*")/).map(e=>e[0]==='"'?e:e.replace(/[{},:]/g,s=>b[s])).join("")+")]",!0)}static parseSLID(t,e=!1){let s=t.match(/\[\((.*?)\)\]/s);if(!s)throw new SyntaxError("Missing SLID boundary marker(s)");const r=s[1].replace(/\)\\\]/g,")]").split(O).filter(n=>!/^(\s*|\/\*.*\*\/)$/.test(n));s=void 0;const i=()=>{const n=r.shift();if(S.test(n))return/n$/i.test(n)?BigInt(n.slice(0,-1)):/^[+-]?0b/i.test(n)?parseInt(n.replace(/0b/i,""),2):/^[+-]?0o/i.test(n)?parseInt(n.replace(/0o/i,""),8):/^[+-]?0x/i.test(n)?parseInt(n.replace(/0x/i,""),16):parseFloat(n);if(n==="'"||n==='"')throw new SyntaxError(`Unmatched ${n} in SLID`);return n[0]!=="'"&&n[0]!=='"'?n:m(n.slice(1,-1))},h=()=>{if(r[0]!=="["){if(e)switch(r[0]){case"false":return r.shift(),!1;case"null":return r.shift(),null;case"true":return r.shift(),!0}else switch(r[0]){case"@f":return r.shift(),!1;case"@n":return r.shift(),null;case"@t":return r.shift(),!0;case"@u":r.shift();return}return i()}return r.shift(),o.call(this)},o=()=>{const n=new d;for(;r.length&&r[0]!=="]";){let f;if(r[1]==="=")f=i(),r.shift();else if(!e&&r[0]==="@e"){r.shift(),++n.next;continue}n.set(f,h())}return r[0]==="]"&&r.shift(),n},_=o();if(r.length)throw new SyntaxError("Malformed SLID");return _}pop(t={}){if(this._locked)throw new TypeError("NANOS: Cannot pop after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot pop after index lock");if(this._next)return this.delete(--this._next,t)}push(...t){if(this._locked)throw new TypeError("NANOS: Cannot push after locking");const e=this._rio?.batch||(n=>n()),s=this._options,r=s.transform,i=(n,f=0)=>{const a=this._next,k=a+f;for(let[g,u]of n)if(c(g)){const x=a+parseInt(g,10);r&&(this.#i(u)||this.#r(u))&&(u=this.similar(u)),this.set(x,u)}else this.set(g,u);this._next<k&&(this._next=k)},h=n=>{for(let[f,a]of n)c(f)?this.#i(a)?h(this.similar(a).entries()):(this.#r(a)&&(a=this.similar(a)),this.set(void 0,a)):this.set(f,a)},o=r==="sets"?h:i,_=n=>{p(n)?o(Object.entries(n)):Array.isArray(n)?o(Object.entries(n),n.length):n instanceof d?o(n.entries(),n.next):!s.opaqueMaps&&n instanceof Map?o(n.entries()):!s.opaqueSets&&n instanceof Set?o([...n.values()].entries()):this.set(void 0,n)};return e(()=>t.forEach(_)),this}redact(...t){for(const e of t){if(e===!0&&(this._redacted=!0),this._redacted===!0)return;this._redacted||={},c(e)?this._redacted[0]=!0:this._redacted[e]=!0}return this._rio?.changed(),this}#n(t,e,s){const r=(i,h)=>{Object.hasOwn(this._storage,i)&&(this._storage[i+h]=this._storage[i],delete this._storage[i])};if(s>0){e+s>this._next&&(this._next=e+s);for(let i=e;--i>=t;)r(i,s)}else if(s<0){e>=this._next&&(this._next+=s);for(let i=t;i<e;++i)r(i,s)}s&&(this._keys=this._keys.map(i=>{const h=c(i)&&parseInt(i,10);return h!==!1&&h>=t&&h<e?h+s+"":i}))}reverse(){if(this._locked)throw new TypeError("NANOS: Cannot reverse after locking");const t=this._storage,e=[],s={},r=this._next-1;for(const i of this._keys.toReversed()){const h=c(i)?String(r-parseInt(i,10)):i;s[h]=t[i],e.push(h)}return this._storage=s,this._keys=e,this._rio?.changed(),this}*reverseEntries(t={}){t=this.#e(t,"compact"),this._rio?.depend();const e=this._storage,s=t.compact?i=>c(i)?parseInt(i,10):i:i=>i,r=t.raw||!this._rio?.get?i=>i:i=>this.#t(i);for(const i of this._keys.toReversed())yield[s(i),r(e[i])]}get rio(){return this._rio}set rio(t){t?t?.batch&&t.changed&&t.create&&t.depend&&(this._rio=t):delete this._rio}set(t,e,s={}){if(s=this.#e(s,"insert"),this._locked)throw new TypeError("NANOS: Cannot set after locking");if(t===void 0&&(t=this._next),t=this.#s(t),t===void 0)return;const r=String(t),i=c(r)&&parseInt(r,10);let h=!1;if(!Object.hasOwn(this._storage,r)){if(h=!0,s.insert)if(i===!1||!this._next)this._keys.unshift(r);else{let o=this._keys.length;for(;o>0&&(!c(this._keys[o-1])||i<this._keys[o-1]);)--o;this._keys.splice(o,0,r)}else if(i===!1||i>=this._next)this._keys.push(r);else{let o=0;for(;o<this._keys.length&&(!c(this._keys[o])||i>this._keys[o]);)++o;this._keys.splice(o,0,r)}i!==!1&&i>=this._next&&(this._next=i+1)}return!s.raw&&this._rio?.onSet&&(e=this._rio.onSet(this,t,e)),this._options.transform&&(this.#r(e)||this.#i(e))?this._storage[r]=this.similar(e):this._storage[r]=e,this._lockNew&&this.lock(r),h&&this._rio?.changed(),e}setRaw(t,e,s={}){return s=this.#e(s,"insert",{raw:!0}),this.set(t,e,s)}#r(t){return Array.isArray(t)||!this._options.opaqueSets&&t instanceof Set}setOptions(t){return Object.assign(this._options,t),this}setRIO(t){return this.rio=t,this}shift(t={}){if(this._locked)throw new TypeError("NANOS: Cannot shift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot shift after index lock");return this._next?(this._rio?.batch||(s=>s()))(()=>{const s=this.delete(0,t);return this.#n(1,this._next,-1),s}):void 0}get size(){return this._rio?.depend(),this._keys.length}similar(...t){const e=new this.constructor;return e.setOptions(this._options),e.rio=this._rio?.create(),t.length&&e.push(...t),e}get storage(){return this._rio?.depend(),this._storage}toReversed(){return this._rio?.depend(),this.similar().fromPairs(this.toJSON()).reverse()}toJSON(){return this._rio?.depend(),{type:"@NANOS@",next:this._next,pairs:this.pairs(!0)}}toSLID({compact:t=!1,redact:e=!1}={}){this._rio?.depend();const s=o=>y(o).replace(/\)]/g,")\\]");function r(o){const _=[];for(const n of o){const f=_.length?_.slice(-1).slice(-1):"",a=f+(n[0]||"");f&&!/['"\[\]]/.test(a)&&_.push(" "),_.push(n)}return _.join("")}function i(o){switch(o){case!1:return"@f";case null:return"@n";case!0:return"@t";case void 0:return"@u"}switch(typeof o){case"bigint":return o.toString()+"n";case"number":return o.toString();case"string":return/^[!()*.,:;<>?A-Z{}_][!()*.,0-9:;<>?@A-Z{}_-]*$/i.test(o)?o:"'"+s(o)+"'"}return(p(o)||Array.isArray(o)||o instanceof Map||o instanceof Set)&&(o=new this.constructor(o)),o instanceof d?"["+h(o)+"]":"@u/*??*/"}function h(o){let _=0;if(e&&o._redacted===!0)return e==="comment"?"/*???*/":"";const n=[];for(const f of o.entries())if(c(f[0])){if(e&&o.isRedacted(0)){e==="comment"&&n.push("/*?*/");continue}const a=parseInt(f[0],10);n.push((a===_?"":`${a}=`)+i(f[1])),_=a+1}else e&&o.isRedacted(f[0])?e==="comment"&&n.push("/*?=?*/"):n.push(i(f[0])+"="+i(f[1]));return t?r(n):n.join(" ")}return"[("+h(this).replace(/\)\]/g,")\\]")+")]"}toString(t={}){return this.toSLID({redact:!0,...t})}unshift(...t){if(this._locked)throw new TypeError("NANOS: Cannot unshift after locking");if(this._lockInd)throw new TypeError("NANOS: Cannot unshift after index lock");return(this._rio?.batch||(s=>s()))(()=>t.toReversed().forEach(s=>{s instanceof d||(s=this.similar(s)),this.#n(0,this._next,s.next),this.fromEntries(s.entries(),!0)})),this}*values(t={}){this._rio?.depend();const e=t.raw||!this._rio?.get?s=>s:s=>this.#t(s);for(const s of this.indexKeys())yield e(this.atRaw(s))}#s(t){if(!(I(t)&&(t=parseInt(t,10)+this._next,t<0)))return t}}d.prototype.get=d.prototype.at,d.toSLID=(l,t={})=>l instanceof d?l.toSLID(t):new d(l).toSLID(t);const{parseQJSON:A,parseSLID:N,toSLID:j}=d;export{d as NANOS,d as default,c as isIndex,I as isNegIndex,A as parseQJSON,N as parseSLID,j as toSLID};
